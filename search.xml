<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/2093/02/12/helloworld/"/>
      <url>/2093/02/12/helloworld/</url>
      
        <content type="html"><![CDATA[<img src="/image/home.png" class="">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CurrentHashMap1</title>
      <link href="/2020/08/18/CurrentHashMap1/"/>
      <url>/2020/08/18/CurrentHashMap1/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><a id="more"></a><img src="/image/xxxx/xxxxx.png" class="" title="xxxx">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>volatile1</title>
      <link href="/2020/08/18/volatile1/"/>
      <url>/2020/08/18/volatile1/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><a id="more"></a><img src="/image/xxxx/xxxxx.png" class="" title="xxxx">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>synchronized相关-对象头&amp;锁机制</title>
      <link href="/2020/08/15/synchronized1/"/>
      <url>/2020/08/15/synchronized1/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  之前面试中有被问到synchronized及Java锁机制相关的问题，所以总结一下相关知识点。</p><a id="more"></a><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><h4 id="对象头的结构"><a href="#对象头的结构" class="headerlink" title="对象头的结构"></a>对象头的结构</h4><p>  synchronized锁住的目标是Java中的对象，那么他到底依赖于什么控制的呢？<br>  答案就是—对象头，他是对象在内存中的存储结构之一。<br>  所以先来了解下对象头是啥样的：</p><blockquote><p>一般对象的对象头由两部分组成<br>1.klass pointer(指针，指向其类元数据的信息),<br>2.Mark word(存储对象的运行时数据，包括哈希码，锁状态等)<br>如果是数组对象则还存有array length信息</p></blockquote><h4 id="Mark-word"><a href="#Mark-word" class="headerlink" title="Mark word"></a>Mark word</h4><p>  对象头的三个结构中，与synchronized关联紧密的就是第二部分 Mark word。<br>  因为他维护着对象的锁标记信息。</p><img src="/image/synchronized/synchronized5.png" class="" title="64位 Mark word结构"><p>1.identity_hashcode：对象的Hash值，这里注意如果对象的identity_hashcode不为空，那么他是没法进入偏向锁状态的，因为内存空间被占用了<br>2.age：GC分代年龄<br>3.biased_lock：偏向锁标志<br>4.lock：锁状态标志<br>5.thread：偏向锁状态偏向的线程标识<br>6.epoch：偏向时间戳<br>7.pointer_to_lock_record：指向线程栈中Lock Record的指针<br>8.pointer_to_heavyweight_monitor：指向堆中的monitor对象的指针</p><p>  其中biased_block和lock即锁标识的信息:</p><img src="/image/synchronized/synchronized1.png" class="" title="锁状态标记"><h3 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h3><p>  对象头中记录了对象不同的锁状态，当触发了对应条件时就会引起其状态的变化，这个过程被称作锁升级。</p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>  当有线程获取到锁资源时就会升级为偏向锁，并在对象头中记录偏向的线程标识，也就是获取到锁资源的线程。</p><blockquote><p>引入偏向锁是因为在一个线程多次获取同一个锁的场景下，如果每次都按照竞争锁的方式去操作未免会造成平白的消耗。<br>而偏向锁记录了当前拥有锁的线程的标识信息，当同一线程多次去获取该锁时可以直接依据该标识判断，从而减小获取锁的消耗。</p></blockquote><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>  偏向锁是无竞争场景下的，假设这样一种情况：<br>  thread1先获取到了某个对象的锁，thread2慢了一步，获取失败。<br>  那么此时如何处理thread2？<br>  这里的设计是按照乐观的设想，thread1会很快释放锁资源，所以将偏向锁升级为轻量级锁，让thread2自旋不断尝试获取锁资源。</p><h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>  轻量级锁是在乐观设想的前提下让获取失败的线程自旋等待。<br>  但考虑到最坏的情况，thread1因为某些原因占用时间超出了可接受的范围，如果让thread2一直自旋，甚至后面又来了N个线程也在自旋，这样就浪费了大量的CPU资源，显然是不合理的。<br>  所以当线程自旋一定次数还未获得锁资源时，轻量级锁就会升级为重量级锁，让这些尝试获取锁资源的线程通通阻塞，等待锁被释放后再唤醒他们。</p><blockquote><p>重量级锁是jdk1.6之前使用的锁机制，因为其底层依赖于互斥锁，涉及用户态和内核态的转换，进程的上下文切换等，性能影响较大，所以才引入偏向锁和轻量级锁来改善</p></blockquote><p>  关于偏向锁需要注意几点：<br>  1). 因为无锁的内存结构中identity_hashcode与偏向锁中的thread的内存空间是冲突的，也就是两者只能存一个，当identity_hashcode不为空的时候，是无法偏向的，这时候会直接升级为轻量级锁<br>  2). 有时候会发现状态是偏向锁，biased_lock也显示是1标识偏向锁，但其实thread是空的，这时候表示处于可以偏向的状态</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><pre><code>  为了写本篇文章着实找了许多博客参考，不过大部分都是一些概念，底层实现逻辑的描述较少。不过还是对synchronized及锁机制有了更清晰的理解，这里照常做一下总结：1.本文只介绍了对象头及synchronized相关的锁机制，如果想了解更多建议阅读参考中强烈推荐的那篇文章2.关于synchronized的使用及理解，我认为主要把握住一点，他锁住的是对象(类对象或者实例对象)3.偏向锁，轻量级锁，重量级锁的加锁释放锁的过程本来想写一下的但是反复写了几次都觉得说的不够清楚，  所以就暂时不写出来误导人了，主要还有些细节没有验证清楚4.验证锁的切换可以借用jol输出对象头信息观察锁标志的变化</code></pre><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote><p><a href="https://www.cnblogs.com/LemonFive/p/11246086.html" target="_blank" rel="noopener">盘一盘 synchronized （一）—— 从打印Java对象头说起</a><br><a href="https://zhuanlan.zhihu.com/p/150791816" target="_blank" rel="noopener">深入理解synchronized底层源码</a><br>强烈推荐-》<a href="https://github.com/farmerjohngit/myblog/issues/12" target="_blank" rel="noopener">死磕Synchronized底层实现–概论</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跳跃链表</title>
      <link href="/2020/07/21/skipList1/"/>
      <url>/2020/07/21/skipList1/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  最近有被问到redis中zset类型的数据结构–跳表，所以本章就跳表的原理及redis中的实现做一个总结。</p><a id="more"></a><h3 id="跳表原理"><a href="#跳表原理" class="headerlink" title="跳表原理"></a>跳表原理</h3><p>  跳表的结构很简单，就是在一个链表的基础上，建立n层索引层。</p><img src="/image/skiplist/skiplist1.png" class="" title="跳表结构"><p>  如上图所示，借助索引层，可以使得查询按照类似二分查找的方式更快定位目标节点的位置，而不必遍历整个链表。<br>  也因此，跳表中是不允许重复的值的。</p><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>  跳表可以理解为几层链表，只不过一层比一层”稀疏”。实现跳表一个关键点在于确定节点的层数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 采用随机的方式确定每一个节点的层数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">randomLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">while</span> (r.nextInt(<span class="number">10</span>) &lt; p &amp;&amp; level &lt; MAX_LEVEL) &#123;</span><br><span class="line">        level++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 跳表节点类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SkipListNode</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 下一个节点</span></span><br><span class="line">    <span class="keyword">private</span> SkipListNode next;</span><br><span class="line">    <span class="comment">// 下一层节点</span></span><br><span class="line">    <span class="keyword">private</span> SkipListNode down;</span><br><span class="line">    <span class="comment">// 节点所在层数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> level;</span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="keyword">private</span> Integer value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SkipListNode</span><span class="params">(<span class="keyword">int</span> level, Integer value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.level = level;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SkipListNode</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   这里实现跳表是定义了每一个节点(相同值不同层当作不同节点)，通过节点的next指针和down指针操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 跳表定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SkipList</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 最大层数，对层数随机的限制</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_LEVEL = <span class="number">16</span>;</span><br><span class="line">    <span class="comment">// 头节点，是一个虚节点，无实际值</span></span><br><span class="line">    <span class="keyword">private</span> SkipListNode head;</span><br><span class="line">    <span class="comment">// 跳表长度，实际值的数量，不包括索引节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">// 当前跳表最大的层数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxLevel;</span><br><span class="line">    <span class="comment">// 用来随机层数</span></span><br><span class="line">    <span class="keyword">private</span> Random r = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法，初始化头节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SkipList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">new</span> SkipListNode(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">this</span>.head.setNext(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.head.setDown(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.maxLevel = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新增操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 校验，不让插重复值</span></span><br><span class="line">    <span class="keyword">if</span> (find(value)) &#123;</span><br><span class="line">        System.out.println(<span class="string">"值已存在"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1. 随机计算新节点层次</span></span><br><span class="line">    <span class="keyword">int</span> currentMaxLevel = randomLevel();</span><br><span class="line">    <span class="comment">// 2. 遍历每一层插入节点</span></span><br><span class="line">    <span class="comment">// 2.1 判断当前最大层次是否满足</span></span><br><span class="line">    <span class="keyword">if</span> (currentMaxLevel &gt; maxLevel) &#123;</span><br><span class="line">        <span class="keyword">for</span> (; maxLevel &lt; currentMaxLevel; maxLevel++) &#123;</span><br><span class="line">            SkipListNode newHead = <span class="keyword">new</span> SkipListNode(maxLevel + <span class="number">1</span>, <span class="keyword">null</span>);</span><br><span class="line">            newHead.setDown(head);</span><br><span class="line">            head = newHead;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.2 取头节点作为游标</span></span><br><span class="line">    SkipListNode cursorHeadNode = head;</span><br><span class="line">    <span class="comment">// 2.3 新建节点</span></span><br><span class="line">    SkipListNode newNode = <span class="keyword">new</span> SkipListNode(maxLevel, value);</span><br><span class="line">    <span class="comment">// 2.4 循环处理</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = maxLevel; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        SkipListNode cursorNode = cursorHeadNode.getNext();</span><br><span class="line">        <span class="comment">// 当前层次大于新建节点最大层次，下降一层并跳过</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; currentMaxLevel) &#123;</span><br><span class="line">            cursorHeadNode = cursorHeadNode.getDown();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前层次遍历</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 头节点的下一节点为空</span></span><br><span class="line">            <span class="keyword">if</span> (cursorNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">                cursorHeadNode.setNext(newNode);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第一个节点值比新增值大</span></span><br><span class="line">            <span class="keyword">if</span> (cursorNode.getValue() &gt; value) &#123;</span><br><span class="line">                cursorHeadNode.setNext(newNode);</span><br><span class="line">                newNode.setNext(cursorNode);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cursorNode.getValue() &lt; value) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cursorNode.getNext() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 跟在最后一个节点后面</span></span><br><span class="line">                    cursorNode.setNext(newNode);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cursorNode.getNext().getValue() &gt; value) &#123;</span><br><span class="line">                    <span class="comment">// 插入两者中间</span></span><br><span class="line">                    newNode.setNext(cursorNode.getNext());</span><br><span class="line">                    cursorNode.setNext(newNode);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 移动到下一节点</span></span><br><span class="line">            <span class="keyword">if</span> (cursorNode.getNext().getValue() &lt; value) &#123;</span><br><span class="line">                cursorNode = cursorNode.getNext();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cursorHeadNode = cursorHeadNode.getDown();</span><br><span class="line">        <span class="comment">// 设置新节点的下一节点</span></span><br><span class="line">        SkipListNode nextNewNode = <span class="keyword">new</span> SkipListNode(i - <span class="number">1</span>, value);</span><br><span class="line">        newNode.setDown(nextNewNode);</span><br><span class="line">        newNode = nextNewNode;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 游标节点</span></span><br><span class="line">    SkipListNode cursorNode = head;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 游标为null，终止遍历</span></span><br><span class="line">        <span class="keyword">if</span> (cursorNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 头节点为虚节点，所以取下一节点为当前节点与入参做比较</span></span><br><span class="line">        <span class="comment">// 或 已经比较过的节点作为游标，所以也是取他的下一节点做比较</span></span><br><span class="line">        SkipListNode currentNode = cursorNode.getNext();</span><br><span class="line">        <span class="keyword">if</span> (currentNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">            cursorNode = cursorNode.getDown();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 比较当前节点与入参的值</span></span><br><span class="line">        <span class="keyword">if</span> (currentNode.getValue().equals(value)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (currentNode.getValue() &gt; value) &#123;</span><br><span class="line">            <span class="comment">// 当前节点大，游标移动到下一层</span></span><br><span class="line">            cursorNode = cursorNode.getDown();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (currentNode.getValue() &lt; value) &#123;</span><br><span class="line">            <span class="comment">// 当前节点小，下一节点为空，则移动到下一层</span></span><br><span class="line">            <span class="keyword">if</span> (currentNode.getNext() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                cursorNode = currentNode.getDown();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前节点小，下一节点不为空但比入参大，移动到下一层</span></span><br><span class="line">            <span class="keyword">if</span> (currentNode.getNext().getValue() &gt; value) &#123;</span><br><span class="line">                cursorNode = currentNode.getDown();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前节点小，下一节点不为空且也比入参小，游标移动到下一节点</span></span><br><span class="line">            <span class="keyword">if</span> (currentNode.getNext().getValue() &lt; value) &#123;</span><br><span class="line">                cursorNode = currentNode.getNext();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  以一个个节点实现跳表逻辑的时候发现相比用数组维护同一值的结构，操作要复杂一些。因为会涉及节点的比较及右移，下移。<br>  不过一步一步的实现起来也是对逻辑能力的一种锻炼。<br>  由于时间问题，只实现了插入和查询方法，而且感觉应该还有许多可以优化的地方，就等之后有时间在思考吧。</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">skipListTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SkipList list = <span class="keyword">new</span> SkipList();</span><br><span class="line">    list.insert(<span class="number">1</span>);</span><br><span class="line">    list.insert(<span class="number">5</span>);</span><br><span class="line">    list.insert(<span class="number">9</span>);</span><br><span class="line">    list.insert(<span class="number">12</span>);</span><br><span class="line">    list.insert(<span class="number">3</span>);</span><br><span class="line">    list.insert(<span class="number">34</span>);</span><br><span class="line">    list.insert(<span class="number">20</span>);</span><br><span class="line">    list.insert(<span class="number">11</span>);</span><br><span class="line">    list.insert(<span class="number">6</span>);</span><br><span class="line">    list.insert(<span class="number">8</span>);</span><br><span class="line">    list.insert(<span class="number">2</span>);</span><br><span class="line">    list.insert(<span class="number">4</span>);</span><br><span class="line">    list.insert(<span class="number">33</span>);</span><br><span class="line">    list.insert(<span class="number">21</span>);</span><br><span class="line">    list.insert(<span class="number">19</span>);</span><br><span class="line">    list.insert(<span class="number">25</span>);</span><br><span class="line">    list.insert(<span class="number">72</span>);</span><br><span class="line">    list.insert(<span class="number">13</span>);</span><br><span class="line">    list.insert(<span class="number">15</span>);</span><br><span class="line">    list.insert(<span class="number">7</span>);</span><br><span class="line">    list.insert(<span class="number">32</span>);</span><br><span class="line">    logger.info(<span class="string">"size;&#123;&#125;"</span>, list.getSize());</span><br><span class="line">    list.showData();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/image/skiplist/skiplist2.png" class="" title="测试结果"><p>  测试发现，因为每个新节点的层数都是按照随机的方式决定，那么有可能会导致索引层的不合理。</p><h3 id="redis实现"><a href="#redis实现" class="headerlink" title="redis实现"></a>redis实现</h3><p>  先来看看redis的节点定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zskiplistNode &#123;</span><br><span class="line">    <span class="comment">// 成员对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line">    <span class="comment">// 分值</span></span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="comment">// 后退指针</span></span><br><span class="line">    struct zskiplistNode *backward;</span><br><span class="line">    <span class="comment">// 层</span></span><br><span class="line">    struct zskiplistLevel &#123;</span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        struct zskiplistNode *forward;</span><br><span class="line">        <span class="comment">// 跨度</span></span><br><span class="line">        unsigned <span class="keyword">int</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure><p>  redis的节点定义与上述例子不同，他是在节点内用数组维护了对应层的下一节点。<br>  借用这种思想用Java实现的话：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 节点类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SkipListNode2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer level;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对应每一层的下一节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> SkipListNode2[] nextNodes;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SkipListNode2</span><span class="params">(<span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.level = level;</span><br><span class="line">        <span class="keyword">this</span>.nextNodes = <span class="keyword">new</span> SkipListNode2[level];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLevel</span><span class="params">(Integer level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SkipListNode2[] getNextNodes() &#123;</span><br><span class="line">        <span class="keyword">return</span> nextNodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNextNodes</span><span class="params">(SkipListNode2[] nextNodes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nextNodes = nextNodes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 跳表类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SkipList2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(SkipList2<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_LEVEL = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Random r = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> levelCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 头节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> SkipListNode2 head;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SkipList2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.levelCount = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">new</span> SkipListNode2(MAX_LEVEL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (find(value) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.info(<span class="string">"值已存在"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> level = randomLevel();</span><br><span class="line">        SkipListNode2 newNode = <span class="keyword">new</span> SkipListNode2(level);</span><br><span class="line">        newNode.setLevel(level);</span><br><span class="line">        newNode.setValue(value);</span><br><span class="line">        SkipListNode2[] newNextNodes = <span class="keyword">new</span> SkipListNode2[level];</span><br><span class="line">        newNode.setNextNodes(newNextNodes);</span><br><span class="line">        <span class="comment">// 游标节点</span></span><br><span class="line">        SkipListNode2 cursorNode = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 比较下一节点与入参值，若小于入参值则向后移动</span></span><br><span class="line">            <span class="keyword">while</span> (cursorNode.getNextNodes()[i] != <span class="keyword">null</span></span><br><span class="line">                    &amp;&amp; cursorNode.getNextNodes()[i].getValue() &lt; value) &#123;</span><br><span class="line">                cursorNode = cursorNode.getNextNodes()[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遍历到大于入参值的节点，置为新节点当前层的下一节点</span></span><br><span class="line">            newNextNodes[i] = cursorNode.getNextNodes()[i];</span><br><span class="line">            cursorNode.getNextNodes()[i] = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (level &gt; levelCount) &#123;</span><br><span class="line">            levelCount = level;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 搜索</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> SkipListNode2 <span class="title">find</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 游标节点</span></span><br><span class="line">        SkipListNode2 cursorNode = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = levelCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 比较下一节点与入参值，若小于入参值则向后移动</span></span><br><span class="line">            <span class="keyword">while</span> (cursorNode.getNextNodes()[i] != <span class="keyword">null</span></span><br><span class="line">                    &amp;&amp; cursorNode.getNextNodes()[i].getValue() &lt; value) &#123;</span><br><span class="line">                cursorNode = cursorNode.getNextNodes()[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cursorNode.getNextNodes()[<span class="number">0</span>] != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; cursorNode.getNextNodes()[<span class="number">0</span>].getValue().equals(value)) &#123;</span><br><span class="line">            <span class="keyword">return</span> cursorNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SkipListNode2 cursorNode = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = levelCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 比较下一节点与入参值，若小于入参值则向后移动</span></span><br><span class="line">            <span class="keyword">while</span> (cursorNode.getNextNodes()[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.print(cursorNode.getNextNodes()[i].getValue() + <span class="string">","</span>);</span><br><span class="line">                cursorNode = cursorNode.getNextNodes()[i];</span><br><span class="line">            &#125;</span><br><span class="line">            cursorNode = head;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 随机计算节点最大层次</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">randomLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">while</span> (r.nextInt(<span class="number">10</span>) &lt; p &amp;&amp; level &lt; MAX_LEVEL) &#123;</span><br><span class="line">            level++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这种思路明显要比单一节点的实现更加方便，数组存放了下一节点指针，而不同的下标又表示了不同层的下一节点指针，替代了next和down指针的作用。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><pre><code>  redis用跳表实现zset类型要比上面实现的例子考虑的更多(像节点维护的跨度信息，及zset权重分数的维护等)，不过本章只探讨跳表的实现思路，所以就不详细探讨这方面了。  关于跳表的实现我一开始想的是用一个一个节点去描述跳表结构，看了redis的节点定义及网上的一些示例，才理解用数组去描述的思路。用数组实现的代码看起来有点绕，但是理解了就会觉得很简单，不用像节点那样频繁的转移。数组使得遍历操作变得更加直接。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析AQS(jdk1.8)</title>
      <link href="/2020/07/14/AQS1/"/>
      <url>/2020/07/14/AQS1/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  作为JUC并法包的核心组件，AQS是学习JUC必不可少的一步，本章就来看看AQS是怎样实现同步需求的。</p><a id="more"></a><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p>  state是一个计数值，用来表示同步状态，state&gt;0表示占用了锁，等于0则释放锁，像CountDownLatch中就是用state的值来判断是否释放锁唤醒等待线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// state属性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回当前的state值，因为state是volatile修饰的，所以每次都是读的主存</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置state值，同样基于volatile是直接写的主存</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用CAS方式修改state</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FIFO队列"><a href="#FIFO队列" class="headerlink" title="FIFO队列"></a>FIFO队列</h3><p>  除了使用state表示同步状态，AQS还维护了一个FIFO队列来存储等待的线程信息，直到state==0，才会唤醒头节点的线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 队列节点Node类</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 共享标记</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="comment">// 独占标记</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// waitStatus值，表示取消状态，线程不会再参与竞争</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// waitStatus值，表示后继线程需要出列</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// waitStatus值，当前线程正在等待</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// waitStatus值，表示下一次的共享式同步状态的获取应无条件传播</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待状态</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上一节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line">    <span class="comment">// 下一节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点所属线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 维护条件队列的节点或者存独占/共享模式的标识</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回上一个节点，为空则抛出空指针</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">        Node p = prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">    Node() &#123;   </span><br><span class="line">    &#125;</span><br><span class="line">    Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">        <span class="comment">// 独占/共享失败时调用addWaiter()，通过入参设置独占/共享标识</span></span><br><span class="line">        <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">    Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">        <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  从Node类可以看到，每一个节点都保存了对应线程信息并维护了一个waitStatus信息来判断如何操作。<br>  并且每一个节点都指向了他的前一节点和后一节点，可以看出这个队列是一个双向队列。</p><p>  下面再来看看AQS中是如何操作这个队列的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 队列头节点 头节点如果存在，其waitStatus不会被设置为CANCELLED</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列尾节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点插入队列</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="comment">// 尾节点为空则初始化</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="comment">// 使用CAS保证线程安全</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 尾部插入节点</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置头节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    head = node;</span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line">    node.prev = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前线程加入队列尾部</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  从节点的定义可以看到，这是一个双向队列，AQS维护了指向这个队列头尾的两个指针，每次新增的节点都是从尾部插入。</p><h3 id="获取释放操作"><a href="#获取释放操作" class="headerlink" title="获取释放操作"></a>获取释放操作</h3><p>  在看完了AQS队列结构后，接下来就来看看AQS为实现同步需求提供的一些操作方法。</p><h4 id="“抽象”方法"><a href="#“抽象”方法" class="headerlink" title="“抽象”方法"></a>“抽象”方法</h4><p>  AQS中有几个方法并没有具体实现逻辑，这些方法都需要子类自己去实现，AQS只是定义了方法的含义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 独占模式的获取</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 独占模式的释放</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 共享模式的获取</span></span><br><span class="line"><span class="comment">// 返回结果：</span></span><br><span class="line"><span class="comment">// 1. 负值表示失败</span></span><br><span class="line"><span class="comment">// 2. 0表示成功，但无法再执行获取操作</span></span><br><span class="line"><span class="comment">// 3. 整数表示成功，后续的获取操作也能成功，但需要检查可用性</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 共享模式的释放</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h4><p>  AQS还提供了一些实现了具体逻辑的获取释放操作的模板方法。</p><h5 id="独占模式"><a href="#独占模式" class="headerlink" title="独占模式"></a>独占模式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 独占模式的获取</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 调用tryAcquire()进行独占模式的获取操作</span></span><br><span class="line">    <span class="comment">// 2. tryAcquire() 失败，则调用addWaiter将节点加入队列</span></span><br><span class="line">    <span class="comment">// 3. 调用acquireQueue() 自旋等待</span></span><br><span class="line">    <span class="comment">// 4. 若acquireQueue() 返回结果中断过，中断当前线程</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自旋等待资源释放</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 自旋不停的请求获取操作</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;<span class="comment">// 返回是否中断过</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="comment">// 方法中断，记录结果，节点依然在队列中等待</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            <span class="comment">// 失败，取消正在尝试获取的操作</span></span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应中断的独占模式的获取</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 线程中断，直接抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">        <span class="comment">// 逻辑与acquireQueue()类似，但线程中断会抛异常</span></span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置等待时间的独占模式的获取</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 依然会对中断响应</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">return</span> tryAcquire(arg) ||</span><br><span class="line">        doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待时间的独占模式获取</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 根据入参计算到期时间戳</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 每一次自旋判断时间是否超时</span></span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 独占模式的释放</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用子类实现的tryRelease()方法</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 唤醒头节点的下一节点</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="共享模式"><a href="#共享模式" class="headerlink" title="共享模式"></a>共享模式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 共享模式的获取</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 获取失败，进入队列自旋等待</span></span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加入队列，自旋等待，不响应中断</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 节点加入队列，设置为共享模式</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 自旋不断尝试获取</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 共享模式的释放</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  共享模式的获取同样有响应中断和超时等待两种，逻辑大致与独占式类似就不一一列举。</p><h3 id="条件队列"><a href="#条件队列" class="headerlink" title="条件队列"></a>条件队列</h3><p>  除了Node内部类，AQS中还有个ConditionObject内部类，其内部维护了针对条件队列的方法。<br>  条件队列的元素同样是Node对象，但借助其nextWaiter属性维护。</p><h4 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现了Condition接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><h4 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从条件队列移除，进入等待队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件等待</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">// 进入条件队列</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 判断是否处于同步队列中</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="comment">// 阻塞当前线程</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><pre><code>  AQS实现同步需求的基础就是依赖一个FIFO的队列。当获取操作失败时，就会将当前线程加入队列，用自旋的方式不断尝试获取直到成功。  本章只是从AQS的数据结构及获取释放操作来了解他是如何实现同步需求的，其实还有许多底层实现逻辑值得分析，这里因为篇幅原因就不一一分析了。  AQS的设计确实非常全面，考虑到了各种可能，不过也因此，单看他的源码会觉得难以联系具体场景去深入理解。个人认为最好结合JUC中依赖AQS实现的各种工具类来理解会更透彻些。</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CountDownLatch(jdk1.8)</title>
      <link href="/2020/07/13/CountDownLatch1/"/>
      <url>/2020/07/13/CountDownLatch1/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  本章对CountDownLatch的原理及应用场景总结一下。</p><a id="more"></a><h3 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h3><h4 id="内部类Sync"><a href="#内部类Sync" class="headerlink" title="内部类Sync"></a>内部类Sync</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承了AQS的内部类，使用AQS的state作为计数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4982264981922014374L</span>;</span><br><span class="line">    Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">        setState(count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// countDown操作</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 使用CAS更新state</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造方法，初始化count，可以调用await()使之休眠直到count归零</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使当前线程等待，直到计数count归零才会唤醒</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使当前线程等待，直到计数count归零 或 等待时间==timeout</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireSharedNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计数器递减</span></span><br><span class="line"><span class="comment">// count&gt;0 -1 若-1操作的结果为零则唤醒所有等待线程</span></span><br><span class="line"><span class="comment">// count==0 不做操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调用的AQS方法"><a href="#调用的AQS方法" class="headerlink" title="调用的AQS方法"></a>调用的AQS方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等待阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">// tryAcquireShared(arg)走Sync重写的逻辑判断计数</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里的tryReleaseShared(arg)走的使Sync重写的逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        <span class="comment">// 确认释放，走AQS的释放方法</span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  从源码中可以看到，CountDownLatch的实现依赖于继承了AQS的内部类Sync。<br>  他的操作方法不错，主要就是初始化定义计数阈值，然后通过await()方法阻塞线程直到计数归零，同归countDown()递减控制计数。</p><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mian</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    CountDownLatch masterFlag = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    CountDownLatch slaveFlag = <span class="keyword">new</span> CountDownLatch(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            masterFlag.await(<span class="number">1</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">            logger.info(<span class="string">"thread run not waiting：&#123;&#125;"</span>, Thread.currentThread().getName());</span><br><span class="line">            slaveFlag.countDown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                masterFlag.await();</span><br><span class="line">                logger.info(<span class="string">"start sleep:&#123;&#125;"</span>, Thread.currentThread().getName());</span><br><span class="line">                Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                logger.info(<span class="string">"thread run：&#123;&#125;"</span>, Thread.currentThread().getName());</span><br><span class="line">                slaveFlag.countDown();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">    masterFlag.countDown();</span><br><span class="line">    logger.info(<span class="string">"master countDown"</span>);</span><br><span class="line">    slaveFlag.await();</span><br><span class="line">    logger.info(<span class="string">"slave countDown finish"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  输出结果</p><img src="/image/CountDownLatch/CountDownLatch1.png" class="" title="示例结果"><p>  从结果可以看到，Thread-4因为使用的是<em>await(long, timeUnit)</em> 方法，其等待时间比较短，所以在主线程休眠时就会被唤醒。<br>  而其他线程都是等到主线程休眠计数将<em>masterFlag</em> 计数归零后才被唤醒。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><pre><code>  总的来看CountDownLatch其实很好理解，借助AQS实现一个计数器，以达到控制线程等待唤醒的目的。不过想要理解他的底层实现原理就得了解AQS的实现了，关于AQS的内容就不在本章赘述。  在实际应用中，CountDownLatch应该是控制一批线程相互等待并让其同时被唤醒这种场景。例如批量下载，要求全部下载完之后发送一个成功的提醒。</code></pre><blockquote><p><a href="https://rel-fly.com/2020/07/14/AQS1/">浅析AQS(jdk1.8)</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AOP</title>
      <link href="/2020/07/12/aop1/"/>
      <url>/2020/07/12/aop1/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  本章主要总结下AOP的原理及实现。</p><a id="more"></a><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>  AOP基于代理模式的设计思想，先来看看什么是代理模式</p><img src="/image/aop/aop1.png" class="" title="代理模式的结构"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务接口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> RF</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(String msg)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 真实服务</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> RF</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealService</span> <span class="keyword">implements</span> <span class="title">ServiceInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RealService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"realService info:&#123;&#125;"</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理服务</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> RF</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyService</span> <span class="keyword">implements</span> <span class="title">ServiceInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ProxyService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RealService realService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"proxy service：&#123;&#125;"</span>, msg);</span><br><span class="line">        realService.show(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  代理类与被代理类实现相同的接口，这样保证两者的结构一致性。同时两者又是组合关系，代理类中包含被代理类的实例。</p><p>  代理模式可以在不修改原有代码的前提下，对其进行扩展，符合开放封闭原则，但其缺点是要新建许多代理类。</p><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>  上述实现代理模式的方法也被称为静态代理，其缺点显而易见，所以就有了动态代理的这种方式去实现。</p><h4 id="基于JDK的动态代理"><a href="#基于JDK的动态代理" class="headerlink" title="基于JDK的动态代理"></a>基于JDK的动态代理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现InvocationHandler的代理类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> RF</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkProxy</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(JdkProxy<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> T realService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JdkProxy</span><span class="params">(T realService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.realService = realService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"parameter：&#123;&#125;"</span>, method);</span><br><span class="line">        logger.info(<span class="string">"args:&#123;&#125;"</span>, args[<span class="number">0</span>]);</span><br><span class="line">        method.invoke(realService, args[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    RealService realService = <span class="keyword">new</span> RealService();</span><br><span class="line">    JdkProxy&lt;RealService&gt; handler = <span class="keyword">new</span> JdkProxy&lt;&gt;(realService);</span><br><span class="line">    ServiceInterface serviceInterface = (ServiceInterface) Proxy.newProxyInstance(</span><br><span class="line">            ServiceInterface<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(),</span></span><br><span class="line">            new Class[]&#123;ServiceInterface.class&#125;,</span><br><span class="line">            handler);</span><br><span class="line">    serviceInterface.show(<span class="string">"hello world"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// parameter：public abstract void com.example.demo.proxy.ServiceInterface.show(java.lang.String)</span></span><br><span class="line"><span class="comment">// args:hello world</span></span><br><span class="line"><span class="comment">// realService info:hello world</span></span><br></pre></td></tr></table></figure><p>  这种方式的好处是针对接口的某种扩展只需新建一个实现了<em>InvocationHandler</em> 的代理类，然后调用Proxy的方法就能实现。而不需要像静态代理一样对每一个接口的实例新建一个对应的代理类。</p><h4 id="基于CGLIB的动态代理"><a href="#基于CGLIB的动态代理" class="headerlink" title="基于CGLIB的动态代理"></a>基于CGLIB的动态代理</h4><p>  待补充</p><h3 id="注解方式实现AOP"><a href="#注解方式实现AOP" class="headerlink" title="注解方式实现AOP"></a>注解方式实现AOP</h3><p>  在spring boot中，我们可以更加方便的使用注解的形式实现AOP。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 切面类</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(MyAspect<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"@annotation(com.example.demo.aop.MyLogger)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myPointCut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"myPointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeMethod</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"before time:&#123;&#125;"</span>, LocalDateTime.now());</span><br><span class="line">        MethodSignature signature = (MethodSignature) joinPoint.getSignature();</span><br><span class="line">        Method method = signature.getMethod();</span><br><span class="line">        logger.info(<span class="string">"method name:&#123;&#125;"</span>, method.getName());</span><br><span class="line">        MyLogger myAnnotation = method.getAnnotation(MyLogger<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != myAnnotation) &#123;</span><br><span class="line">            logger.info(<span class="string">"annotation name:&#123;&#125;"</span>, myAnnotation.name());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取接口入参</span></span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != args) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Object o : args) &#123;</span><br><span class="line">                sb.append(o).append(<span class="string">","</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出接口入参</span></span><br><span class="line">        logger.info(<span class="string">"parameter:&#123;&#125;"</span>, sb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"myPointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"after time:&#123;&#125;"</span>, LocalDateTime.now());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyLogger &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用注解标记目标接口</span></span><br><span class="line"><span class="meta">@GetMapping</span>(value = <span class="string">"/test/send"</span>)</span><br><span class="line"><span class="meta">@MyLogger</span>(name = <span class="string">"hello world"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(@RequestParam(<span class="string">"message"</span>)</span> String message,</span></span><br><span class="line"><span class="function">                 @<span class="title">RequestParam</span><span class="params">(<span class="string">"userId"</span>)</span> Integer userId) </span>&#123;</span><br><span class="line">    logger.info(<span class="string">"do something·······:&#123;&#125;,&#123;&#125;"</span>, message, userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/image/aop/aop2.png" class="" title="调用结果"><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><pre><code>  AOP是一种面向切面编程的思想，他的目的是将不影响业务逻辑的共同操作给提出来，将其与主逻辑分离，一方面能够简化代码，一方面达到解耦的目的。  这些分离出来的操作又按照需求插入到主逻辑的代码间隙中，所以被形象的成为面向切面编程。  其应用场景很多，最常见的就是类似上述例子中接口入参的日志输出，这样可以不用在每个接口开头去写一行日志输出的代码了。  而动态代理的实现原理可以理解为对字节码的增强，其会在运行时对目标类的字节码进行修改，增加指定的切面操作的内容。</code></pre><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote><p> <a href="https://refactoringguru.cn/design-patterns/proxy" target="_blank" rel="noopener">代理设计模式</a><br> <a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1264804593397984#0" target="_blank" rel="noopener">动态代理-廖雪峰的官方网站</a><br> <a href="https://www.cnblogs.com/gonjan-blog/p/6685611.html" target="_blank" rel="noopener">java动态代理实现与原理详细分析</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> AOP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal(jdk1.8)</title>
      <link href="/2020/07/02/ThreadLocal1/"/>
      <url>/2020/07/02/ThreadLocal1/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  ThreadLocal，也被称作线程本地变量，他为每一个线程创建了变量的副本，使得线程能够访问各自的变量副本，互不影响。</p><a id="more"></a><h3 id="属性信息"><a href="#属性信息" class="headerlink" title="属性信息"></a>属性信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于关联线程的线性哈希</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下一个哈希值，使用原子更新</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连续hash计算的增长量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算哈希的方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用原子操作计算</span></span><br><span class="line">    <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 赋值方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取当前线程的ThreadLocalMap实例</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">// 判断非空 进行初始化及赋值操作</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 这里的this是当前ThreadLocal实例</span></span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取值方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程对象</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取当前线程的ThreadLocalMap实例</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">// 判断map非空，取值</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// map为空 进行初始化</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定线程对象的ThreadLocalMap</span></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ThreadLocalMap的初始化及赋值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里的this是当前ThreadLocal实例</span></span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 调用ThreadLocalMap的remove清理</span></span><br><span class="line">        m.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  可以从set()看到，这里是将ThreadLocal实例作为map的key存储对应的值。因为ThreadLocalMap属于每个线程私有的变量，通过不同的ThreadLocal实例区分不同的变量。</p><h3 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h3><p>  ThreadLocalMap是ThreadLocal内部定义的一个key-value结构的内部类，用于存储线程内部的变量值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造方法</span></span><br><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">    <span class="comment">// 这里使用ThreadLocal的哈希值计算数组下标，与HashMap的逻辑相似</span></span><br><span class="line">    <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">    table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过key(ThreadLocal)获取value</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理value</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="comment">// 手动置空要清除的项</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// 数组长度修改了，重新计算下标</span></span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><p>  从上述源码可以看出，每一个Thread都定义了一个ThreadLocalMap的属性用来存储自己的局部变量，map的key是ThreadLocal，通过其哈希值计算数组下标。<br>  不同的变量可以通过定义新的ThreadLocal存储在Thread中。<br>  而不同的Thread访问的永远是自己的map，互不影响。</p><img src="/image/ThreadLocal/ThreadLocal1.png" class="" title="ThreadLocal结构"><h3 id="内存溢出问题"><a href="#内存溢出问题" class="headerlink" title="内存溢出问题"></a>内存溢出问题</h3><p>  ThreadLocalMap的key为弱引用，但value仍然是强引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    Object value;</span><br><span class="line">    <span class="comment">// 这里的k 用的弱引用</span></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  Entry的key是弱引用指向ThreadLocal实例，这样做的目的是能够及时释放ThreadLocal防止内存溢<br>  出。带来的问题是，value是强引用，需要手动清理，否则累积过多会导致内存溢出。<br>  每次使用完后，需要记得调用ThreadLocal的remove()方法，这样就能避免内存溢出的问题。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DelayQueue(jdk1.8)</title>
      <link href="/2020/06/30/DelayQueue1/"/>
      <url>/2020/06/30/DelayQueue1/</url>
      
        <content type="html"><![CDATA[<h3 id="DelayQueue简介"><a href="#DelayQueue简介" class="headerlink" title="DelayQueue简介"></a>DelayQueue简介</h3><pre><code>DelayQueue(延迟队列)是java.util.concurrent包下的适用于一些非即时执行场景下的并发集合。数据以PriorityQueue的结构存储，借助ReentrantLock保证线程安全，使用Condition完成对线程的精确控制。</code></pre><a id="more"></a><p>类定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueue</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Delayed</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; </span></span><br></pre></td></tr></table></figure><p>  从类定义可以看到，队列中的元素对象都需要实现Delayed接口，通过实现Delayed的compareTo()和getDelay()方法实现元素的排序和取出消费的判断。<br>  而DelayQueue本身是BlockingQueue的一个实现，未到执行时间的元素对象不会被取出，而是阻塞当前线程让其等待至任务的执行时间。</p><h3 id="属性信息"><a href="#属性信息" class="headerlink" title="属性信息"></a>属性信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可重入锁，用来保证集合操作的线程安全</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列数据用优先级队列存储</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PriorityQueue&lt;E&gt; q = <span class="keyword">new</span> PriorityQueue&lt;E&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前线程</span></span><br><span class="line"><span class="keyword">private</span> Thread leader = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Condition用来控制线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition available = lock.newCondition();</span><br></pre></td></tr></table></figure><p>  这里定义的线程leader，参考的多线程的Leader/Follower模式设计。<br>  其思想是当有多个消费者线程去获取队列的元素对象时，同一个时刻只有一个线程成为leader等待队首对象，当取得队首对象时就通知其他的线程取代他成为leader等待下一个队首。</p><p>  Condition这里用来精确的控制线程，当等待的队首对象还未到执行时间时，会使用Condition的await()方法让当前线程等待。</p><h3 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入队方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        q.offer(e);<span class="comment">// 调用PriorityQueue的入队方法</span></span><br><span class="line">        <span class="keyword">if</span> (q.peek() == e) &#123;</span><br><span class="line">            <span class="comment">// 队首元素是新增的元素 唤醒等待线程来处理</span></span><br><span class="line">            leader = <span class="keyword">null</span>;</span><br><span class="line">            available.signal();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 弹出队首元素   仍然是用ReenTrantLock保证线程安全</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        E first = q.peek();</span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span> || first.getDelay(NANOSECONDS) &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> q.poll();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();<span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            E first = q.peek();</span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">                available.await();<span class="comment">// 无队首表明队列为空 则让线程等待</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);<span class="comment">// 获取队首任务的剩余执行时间</span></span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> q.poll();<span class="comment">// 队首任务可以执行 弹出</span></span><br><span class="line">                first = <span class="keyword">null</span>; <span class="comment">// don't retain ref while waiting</span></span><br><span class="line">                <span class="comment">// 任务还需等待，判断leader</span></span><br><span class="line">                <span class="keyword">if</span> (leader != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">// leader不为空，则当前线程等待，由leader线程等待队首任务</span></span><br><span class="line">                    available.await();</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// leader为空，当前线程成为新的leader</span></span><br><span class="line">                    Thread thisThread = Thread.currentThread();</span><br><span class="line">                    leader = thisThread;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 设置leader线程的等待时间，确保队首任务执行的时间点就能唤醒继续处理</span></span><br><span class="line">                        available.awaitNanos(delay);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                            <span class="comment">// 最后置空leader，避免线程处理任务的时候继续占用leader</span></span><br><span class="line">                            leader = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; q.peek() != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// leader为空并且有待处理的任务，唤醒其他线程</span></span><br><span class="line">            available.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  DelayQueue最重要的方法便是take()，消费者线程通过调用take()去依次取出队首任务进行处理。<br>  只要理解了Leader/Follower模式就不难理解take()的逻辑。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>  这里用一个单线程生产者/消费者的示例展示下DelayQueue的基本用法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DelayQueue队列元素类的定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayTask</span> <span class="keyword">implements</span> <span class="title">Delayed</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 延迟时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Long delay;</span><br><span class="line">    <span class="comment">// 执行时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Long exprie;</span><br><span class="line">    <span class="comment">// 创建时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Long create;</span><br><span class="line">    <span class="comment">// 任务信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String msg;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelayTask</span><span class="params">(Long delay, String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.delay = delay;</span><br><span class="line">        <span class="keyword">this</span>.create = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">this</span>.exprie = create + delay;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">return</span> unit.convert(exprie - now, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> delay1 = getDelay(TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">long</span> delay2 = o.getDelay(TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> Long.compare(delay1, delay2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(<span class="string">"delay:"</span>).append(getDelay(TimeUnit.SECONDS)).append(<span class="string">"msg:"</span>).append(msg);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delayed接口的定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Delayed</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Delayed</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the remaining delay associated with this object, in the</span></span><br><span class="line"><span class="comment">     * given time unit.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit the time unit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the remaining delay; zero or negative values indicate</span></span><br><span class="line"><span class="comment">     * that the delay has already elapsed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  DelayQueue中的元素类需要实现Delayed，实现getDelay()计算任务的剩余执行时间。<br>  PriorityQueue中的元素都需要继承Comparable，否则无法排序，这里是通过让Delayed继承来实现，然后在子类中重写compareTo()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任务生产逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">producer</span><span class="params">(DelayQueue&lt;DelayTask&gt; queue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            String msg = <span class="string">"aaaaa"</span> + i;</span><br><span class="line">            <span class="comment">// 为了便于测试，这里每隔一段时间往队列中加任务</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            DelayTask task = <span class="keyword">new</span> DelayTask(<span class="number">100000L</span>, msg);</span><br><span class="line">            queue.offer(task);</span><br><span class="line">            logger.info(<span class="string">"生产任务：&#123;&#125;"</span>, task.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务消费逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">consumer</span><span class="params">(DelayQueue&lt;DelayTask&gt; queue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            DelayTask task = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 调用take()取出任务</span></span><br><span class="line">                task = queue.take();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                logger.info(<span class="string">"消费任务异常：&#123;&#125;"</span>, e.getLocalizedMessage());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != task) &#123;</span><br><span class="line">                logger.info(<span class="string">"消费任务:&#123;&#125;"</span>, task.toString());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.info(<span class="string">"没有待消费的任务"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><pre><code>  DelayQueue可应用于一些执行时间较为灵活的场景，比如开课前30分钟发送通知，但是课程的时间并不固定，就可以动态获取课程上课时间后定义一个延迟任务等待执行。  示例中为了方便采用的单线程，但实际开发中，应该用多个线程作为消费者去处理队列中的任务。特别是当任务的逻辑较为复杂时，单线程处理会导致后续任务超时，至于线程数可以根据实际测试去设置。  在写示例的过程中，有想到一个问题，就是如果有较多的任务需要在同一个时间节点执行，这时一个DelayQueue就无法处理。肯定会有大量的任务超时。我的想法是，如果不考虑其他方案，可能需要采用多个DelayQueue，同一个队列中避免执行时间相同的任务。在实际开发中，我们也要注意是否会有大量任务的执行时间点一样。</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PriorityQueue(jdk1.8)</title>
      <link href="/2020/06/29/PriorityQueue1/"/>
      <url>/2020/06/29/PriorityQueue1/</url>
      
        <content type="html"><![CDATA[<h3 id="PriorityQueue简介"><a href="#PriorityQueue简介" class="headerlink" title="PriorityQueue简介"></a>PriorityQueue简介</h3><pre><code>PriorityQueue是java.util包下实现Queue接口的非线程安全的优先级队列也是由数组实现，类似ArrayList通过复制数组达到扩容的操作其特点是可以按照自定义的元素比较器的规则输出队列元素，默认是按小到大的输出顺序该队列不允许插入null或不可比较的对象(没有实现Comparable接口的对象)</code></pre><a id="more"></a><p>类定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><h3 id="属性信息"><a href="#属性信息" class="headerlink" title="属性信息"></a>属性信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认数组长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储元素的数组</span></span><br><span class="line"><span class="keyword">transient</span> Object[] queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素比较器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无参构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定长度的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定元素比较器的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, comparator);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定元素比较器和数组长度的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                     Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Note: This restriction of at least one is not actually needed,</span></span><br><span class="line">    <span class="comment">// but continues for 1.5 compatibility</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.queue = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定集合的构造</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 判断集合入参的类型，初始化元素比较器</span></span><br><span class="line">    <span class="keyword">if</span> (c <span class="keyword">instanceof</span> SortedSet&lt;?&gt;) &#123;</span><br><span class="line">        SortedSet&lt;? extends E&gt; ss = (SortedSet&lt;? extends E&gt;) c;</span><br><span class="line">        <span class="keyword">this</span>.comparator = (Comparator&lt;? <span class="keyword">super</span> E&gt;) ss.comparator();</span><br><span class="line">        initElementsFromCollection(ss);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c <span class="keyword">instanceof</span> PriorityQueue&lt;?&gt;) &#123;</span><br><span class="line">        PriorityQueue&lt;? extends E&gt; pq = (PriorityQueue&lt;? extends E&gt;) c;</span><br><span class="line">        <span class="keyword">this</span>.comparator = (Comparator&lt;? <span class="keyword">super</span> E&gt;) pq.comparator();</span><br><span class="line">        initFromPriorityQueue(pq);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.comparator = <span class="keyword">null</span>;</span><br><span class="line">        initFromCollection(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 元素排序算法，在初始化队列元素时，调用该方法保证队列的顺序符合规则</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (size &gt;&gt;&gt; <span class="number">1</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        siftDown(i, (E) queue[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = queue.length;</span><br><span class="line">    <span class="comment">// 数组小于64则按old+1的两倍扩容，反之，old的1.5倍扩容</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + ((oldCapacity &lt; <span class="number">64</span>) ?</span><br><span class="line">                                     (oldCapacity + <span class="number">2</span>) :</span><br><span class="line">                                     (oldCapacity &gt;&gt; <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 数组长度控制，不超过Integer.MAX_VALUE</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    queue = Arrays.copyOf(queue, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素下沉</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">        siftDownUsingComparator(k, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftDownComparable(k, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDownUsingComparator</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">        <span class="comment">// 计算子节点下标</span></span><br><span class="line">        <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        Object c = queue[child];</span><br><span class="line">        <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 取子节点较小的一个</span></span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">            comparator.compare((E) c, (E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        <span class="comment">// 与子节点比较直到小于等于子节点</span></span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = c;</span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素上浮</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">        siftUpUsingComparator(k, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftUpComparable(k, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUpUsingComparator</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;<span class="comment">// 计算父节点下标</span></span><br><span class="line">        Object e = queue[parent];</span><br><span class="line">        <span class="comment">// 每次和父节点比较，直到大于等于父节点</span></span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) e) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新增元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> i = size;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= queue.length)</span><br><span class="line">        grow(i + <span class="number">1</span>);</span><br><span class="line">    size = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">        queue[<span class="number">0</span>] = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftUp(i, e);<span class="comment">// 对新增元素做上浮操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 弹出队首元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> s = --size;</span><br><span class="line">    modCount++;</span><br><span class="line">    E result = (E) queue[<span class="number">0</span>];<span class="comment">// 弹出队首元素</span></span><br><span class="line">    E x = (E) queue[s];</span><br><span class="line">    queue[s] = <span class="keyword">null</span>;<span class="comment">// 队尾置空</span></span><br><span class="line">    <span class="comment">// 此时队首元素还没变</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        siftDown(<span class="number">0</span>, x);<span class="comment">// 对队尾元素做下沉操作</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">removeAt</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert i &gt;= 0 &amp;&amp; i &lt; size;</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> s = --size;</span><br><span class="line">    <span class="keyword">if</span> (s == i) <span class="comment">// removed last element</span></span><br><span class="line">        queue[i] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        E moved = (E) queue[s];</span><br><span class="line">        queue[s] = <span class="keyword">null</span>;</span><br><span class="line">        siftDown(i, moved);<span class="comment">// 对队尾元素做下沉操作 </span></span><br><span class="line">        <span class="keyword">if</span> (queue[i] == moved) &#123;<span class="comment">// 判断moved元素没有改变</span></span><br><span class="line">            siftUp(i, moved);<span class="comment">// 进行一次上浮操作</span></span><br><span class="line">            <span class="keyword">if</span> (queue[i] != moved)</span><br><span class="line">                <span class="keyword">return</span> moved;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  通过siftDown()和siftUp()方法可以看出，优先队列是借助数组实现了一个二叉堆。</p><blockquote><p>二叉堆是一种特殊的堆，二叉堆是完全二元树（二叉树）或者是近似完全二元树（二叉树）。<br>二叉堆有两种：最大堆和最小堆。最大堆：父结点的键值总是大于或等于任何一个子节点的键值；最小堆：父结点的键值总是小于或等于任何一个子节点的键值。<br>二叉堆一般用数组来表示。如果根节点在数组中下标为0，下标n的元素子节点下标为2n+1和2n+2。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;Integer&gt; queue = Queues.newPriorityQueue();</span><br><span class="line">queue.add(<span class="number">5</span>);</span><br><span class="line">queue.add(<span class="number">3</span>);</span><br><span class="line">queue.add(<span class="number">10</span>);</span><br><span class="line">queue.add(<span class="number">6</span>);</span><br><span class="line">queue.add(<span class="number">2</span>);</span><br><span class="line">queue.add(<span class="number">2</span>);</span><br><span class="line">queue.add(<span class="number">1</span>);</span><br><span class="line">queue.add(<span class="number">6</span>);</span><br><span class="line"><span class="keyword">for</span>(Integer i:queue)&#123;</span><br><span class="line">    System.out.print(i);</span><br><span class="line">    System.out.print(<span class="string">","</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line"><span class="keyword">while</span>(queue.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    System.out.print(queue.poll());</span><br><span class="line">    System.out.print(<span class="string">","</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// 1,3,2,6,5,10,2,6,</span></span><br><span class="line"><span class="comment">// 1,2,2,3,5,6,6,10,</span></span><br></pre></td></tr></table></figure><p>  上述的代码示例可以看到PriorityQueue每次弹出时都会重新整理元素顺序。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><pre><code>优先级队列的结构其实比较简单，是一个用数组实现的二叉堆来保证元素的弹出顺序。</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Collection </category>
          
          <category> Queue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm知识点梳理</title>
      <link href="/2020/06/28/jvm1/"/>
      <url>/2020/06/28/jvm1/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  本章主要对JVM主要的知识点进行梳理总结。</p><a id="more"></a><h3 id="运行时区域"><a href="#运行时区域" class="headerlink" title="运行时区域"></a>运行时区域</h3><ol><li>程序计数器：线程私有，是当前线程执行的字节码的行号指示器，决定命令的执行顺序</li><li>Java虚拟机栈：线程私有，生命周期与线程相同，其描述的是Java方法的内存模型<br><em>每个方法执行时，都会创建一个栈帧，存储局部变量表，操作数栈，动态链接，方法出口等信息。</em><br><em>方法的从执行到完成，对应着栈帧在虚拟机栈中入栈和出栈的过程。</em></li><li>本地方法栈：类似于虚拟机栈，所不同的时，本地方法栈服务的对象时Native方法</li><li>堆：几乎所有的对象实例都在堆中分配内存，也是垃圾收集器管理的主要区域</li><li>方法区：存储已被虚拟机加载的类信息，常量，静态常量，即时编译器编译后的代码等数据</li></ol><h3 id="对象存活判断"><a href="#对象存活判断" class="headerlink" title="对象存活判断"></a>对象存活判断</h3><ol><li>引用计数法：在对象中添加一个引用计数器，每当被引用时则+1，引用失效就-1，当为0时表示对象不会再被使用，其缺陷是没法解决相互循环引用的问题</li><li>可达性分析：将一系列的对象定义为”GC Roots”，然后分析一个对象有没有直达”GC Roots”的引用链，没有则表示对象没有被使用<br>可作为”GC Roots”的对象有以下几种：<ul><li>虚拟机栈，栈帧中局部变量表中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI(Native方法)引用的对象</li></ul></li></ol><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><ol><li>强引用：普遍存在类似”Object o = new Object()”这种，垃圾收集器不会回收掉强引用还存在的对象</li><li>软引用：软引用关联的对象会在系统将要发生内存溢出前进行第二次回收，可通过SoftReference实现</li><li>弱引用：弱引用关联的对象只能生存到下一次垃圾回收之前，可通过WeakReference实现</li><li>虚引用：不影响对象的生存时间，只会在其被回收时收到一个系统通知，可通过PhantomReference实现</li></ol><h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><ol><li>标记-清除算法<br>先标记需要回收的对象，然后再执行回收操作。缺点是效率不高，且会产生大量的内存碎片，可能导致大对象进入时引发不必要的垃圾回收</li><li>复制算法<br>将内存分为两块，每次只使用其中一块。当执行回收操作时，将存活对象复制到空的那块上，然后清空使用过的，效率较高，但空间浪费了</li><li>标记-整理算法<br>以标记-清理算法为基础，在回收前将存活对象向一端移动，然后清理掉边界以外的内存，保证内存的连续性</li><li>分代收集算法<br>在实际虚拟机中采用分代收集算法，根据对象的存活周期划分为年轻代和老年代，根据各个年代的特点采取不同的收集算法<ul><li>年轻代<br>采用复制算法，以HotSpot为例，空间按8:1:1的比例分为Eden，及两个Survivor共三个空间。每次回收时将Eden和Survivor中存活对象复制到空着的那个Survivor中，然后对其内存清理<br>如果空着的Survivor没有足够空间存放，这些对象就会进入老年代</li><li>老年代<br>由于老年代的对象存活率高，通常采用标记-清理或者标记-整理来进行回收</li></ul></li></ol><h4 id="对象分配及回收条件"><a href="#对象分配及回收条件" class="headerlink" title="对象分配及回收条件"></a>对象分配及回收条件</h4><p>  对象优先在Eden中进行分配，若Eden中没有空间可进行分配就会触发MinorGC。</p><p>  大对象直接进入老年代，可通过-XX:PretenureSizeThreshold参数设置这个大对象的判断阈值。</p><p>  长期存活的对象也会进入老年代，每经历过一次MinorGC还存活的对象，其年龄就增加一岁(虚拟机为每一个对象定义了一个年龄计数器)，当达到一定年龄时就会进入老年代(默认15)。<br>  年龄阈值可通过参数-XX:MaxTenuringThreshold控制。</p><p>  当老年代空间不足时就会触发Full GC，Full GC对性能影响较大，应尽量避免。</p><h3 id="JDK命令行工具"><a href="#JDK命令行工具" class="headerlink" title="JDK命令行工具"></a>JDK命令行工具</h3><ol><li>jps:虚拟机进程状态查询，可以显示正在运行的虚拟机进程及LVMID等信息</li><li>jstat：虚拟机统计信息查询，现实虚拟机中各空间的使用信息，GC的统计信息等</li><li>jinfo：实时的查看和调整虚拟机各项参数</li><li>jmap：Java内存映像工具，可用于生成堆转储快照</li><li>jhat：针对jmap生成的快照文件进行分析，可以在浏览器中查看分析结果</li><li>jstack：生成虚拟机当前时刻的线程快照</li></ol>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis-过期策略及淘汰机制</title>
      <link href="/2020/06/27/redis2/"/>
      <url>/2020/06/27/redis2/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  之前有做过redis的一些知识点总结，本章主要针对redis中key的过期策略和淘汰机制内容做一下总结。</p><a id="more"></a><h3 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h3><ol><li><p>定期删除：属于主动删除策略，每隔一段时间随机选择一批key，删除其中过期的</p></li><li><p>惰性删除：通过key获取值时，判断key是否已过期，是则删除</p></li></ol><h3 id="内存淘汰机制"><a href="#内存淘汰机制" class="headerlink" title="内存淘汰机制"></a>内存淘汰机制</h3><p>  redis的过期策略很明显存在过期key未被及时删除而占用内存的情况。如果极端情况下漏了大量key未被及时删除，就过于浪费内存空间了。</p><p>  所以redis还提供了内存淘汰机制应对这种情况：</p><ol><li>内存不足时，新增操作会报错</li><li>内存不足时，移除最近最少使用的key</li><li>内存不足时，随机从所有的key中选一个移除</li><li>内存不足时，移除设置了过期时间且最近最少使用的key</li><li>内存不足时，随机从设置了过期时间的key中选一个移除</li><li>内存不足时，移除设置了过期时间key中，过期时间更早的</li></ol><h3 id="LRU算法"><a href="#LRU算法" class="headerlink" title="LRU算法"></a>LRU算法</h3><p>  redis内存淘汰机制通常使用的是上述第二种，也就是LRU算法，移除最近最少使用的。</p><h3 id="LRU实现逻辑"><a href="#LRU实现逻辑" class="headerlink" title="LRU实现逻辑"></a>LRU实现逻辑</h3><p>  LRU的实现最关键的是记录key的使用顺序，那么先进先出队列就很契合。<br>  每次调用进入队列，若队列已满则弹出尾部元素，但这里得考虑处理重复元素的情况。<br>  所以更好的是使用双向链表，新调用的元素放在头节点，已在链表中的被调用也很容易被置换到头节点，链表满了就删除掉尾节点元素。</p><p>  而reids中的LRU实现没有使用上述两个方法，他的实现逻辑如下：</p><ol><li>每个key对应的value都记录了调用对应的当前时间戳</li><li>使用一个数组存放被调用的key，新增时如果满了就剔除时间戳最大的</li><li>淘汰时就针对数组中的key选择</li></ol><p>  redis基于内存占用的考虑及数据结构的设计考虑没有引用队列或双向列表去做LRU。<br>  其逻辑是仿照LRU的实现逻辑，使用时间戳比较key的使用顺序，并且并没有对所有的key进行计算操作，而是随机的选择一些进行LRU的淘汰。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><pre><code>  本章主要总结了redis过期淘汰涉及的相关概念，重点是redis的LRU逻辑，他是一种近似LRU算法，基于对性能的考虑并没有对所有key进行计算，而是折中的选取一些，兼顾了淘汰的结果和执行的性能。</code></pre>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程和线程</title>
      <link href="/2020/06/25/ProcessAndThread1/"/>
      <url>/2020/06/25/ProcessAndThread1/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  面试中有被问道进程和线程的问题，这个平时看得比较少，这里做一个简单的总结。</p><a id="more"></a><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>  进程：资源分配的基本单位，由进程控制块(Process Control Block, PCB)描述他的基本信息和运行状态<br>  线程：独立调度的基本单位，一个进程可以有多个线程，且这些线程共享进程的资源和数据</p><p>  两者区别：</p><ol><li>进程拥有资源，而线程只能访问所属进程的资源</li><li>通信方式不同，线程间通信可以通过对进程数据的读写完成，进程的通信需要通过IPC(进程间通信技术)完成</li></ol><p>  进程的状态：</p><ol><li>就绪态，等待调度</li><li>运行态</li><li>阻塞态，等待资源分配</li></ol><p>  就绪态和运行态能相互转换，运行态-&gt;阻塞态-&gt;就绪态属于单向转换。</p><p>  线程状态(Java中)：</p><ol><li>初始：NEW 尚未启动的线程处于这种状态</li><li>运行：RUNNABLE 在Java虚拟机上执行的线程处于这种状态</li><li>阻塞：BLOCKED 被阻止等待监视器锁的线程处于这种状态</li><li>等待：WAITING 即无限期地等待另一个线程来执行某一特定操作的线程处于这种状态</li><li>超时等待：TIMED_WAITING 正在等待另一个线程来达到一个指定的等待时间执行动作的线程处于这种状态</li><li>终止：TERMINATED 已退出的线程处于这种状态</li></ol><p>  一个线程可以在给定时间点只能处于一种状态。 这些状态是虚拟机的状态并没有反映任何操作系统线程状态。</p><h3 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h3><h4 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h4><ol><li>先来先服务：非抢占式的调度算法，按照请求的顺序进行调度</li><li>短作业优先：非抢占式的调度算法，按估计运行时间最短的顺序进行调度</li><li>最短剩余时间：短作业优先的抢占式版本，按剩余运行时间的顺序进行调度</li></ol><h4 id="交互式系统"><a href="#交互式系统" class="headerlink" title="交互式系统"></a>交互式系统</h4><ol><li>时间片轮转：每个进程分配一个时间片，用完了就会轮转到下一个进程</li><li>优先级调度：为每一个进程定义一个优先级，按照优先级顺序调度，也可调整进程优先级</li><li>多级反馈队列：类似于时间片轮转，但是设置多个不同时间长度的队列，按时间长短顺序优先，<br>进程没在高优先级(即时间短的)队列中执行完成会依次进入下一队列获取更长的时间片。这样做的目的是减少切换的次数。</li></ol><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><ol><li>管道</li><li>FIFO</li><li>消息队列</li><li>信号量</li><li>共享存储</li><li>套接字</li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMq-设计</title>
      <link href="/2020/06/24/RocketMq2/"/>
      <url>/2020/06/24/RocketMq2/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  上一章基本了解了RocketMQ的架构部分，知道了四个结构的功能和作用，这一章继续看下RocketMQ的一些设计细节。</p><a id="more"></a><h3 id="通信机制"><a href="#通信机制" class="headerlink" title="通信机制"></a>通信机制</h3><p>  在上一章中，我们可以看到NameServer，BrokerServer，Producer，Consumer之间都存在通信<br>  的过程。例如Broker需要注册，发送心跳包给NameServer;生产者，消费者也需要通过NameServer获取Broker的路由信息等。<br>  而RocketMQ中专门有一个rocketmq-remoting负责实现这些通信功能。</p><blockquote><p>rocketmq-remoting 模块是 RocketMQ消息队列中负责网络通信的模块，它几乎被其他所有需<br>要网络通信的模块（诸如rocketmq-client、rocketmq-broker、rocketmq-namesrv）所依赖和引用。为了实现客户端与服务器之间高效的数据请求与接收，RocketMQ消息队列自定义了通信协议并在Netty的基础之上扩展了通信模块。</p></blockquote><h4 id="RemotingCommand"><a href="#RemotingCommand" class="headerlink" title="RemotingCommand"></a>RemotingCommand</h4><blockquote><p>RemotingCommand在消息传输过程中对所有数据内容的封装，不但包含了所有的数据结构，还包含了编码解码操作。</p></blockquote><p>  根据RemotingCommand的定义看看通信的数据结构<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求操作吗|应答响应码</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line"><span class="comment">// 实现语言，这里默认是Java</span></span><br><span class="line"><span class="keyword">private</span> LanguageCode language = LanguageCode.JAVA;</span><br><span class="line"><span class="comment">// 程序版本</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> version = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 相当于requestId</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> opaque = requestId.getAndIncrement();</span><br><span class="line"><span class="comment">// 区分是普通RPC还是onewayRPC得标志</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 传输自定义文本信息</span></span><br><span class="line"><span class="keyword">private</span> String remark;</span><br><span class="line"><span class="comment">// 请求自定义扩展信息</span></span><br><span class="line"><span class="keyword">private</span> HashMap&lt;String, String&gt; extFields;</span><br></pre></td></tr></table></figure></p><p>  除了定义了数据结构，还提供了相应的方法，如：编码解码及创建请求响应的数据结构，这里就不一一看了。</p><h3 id="消息过滤"><a href="#消息过滤" class="headerlink" title="消息过滤"></a>消息过滤</h3><p>  消息过滤主要有两种方式：</p><ol><li><p>Tag过滤方式：消费者指定消费消息时，除了topic还可以配置多个tag。其过程分为两步，首先<br>在store层从ConsumeQueue根据消息的tag的hash值做过滤；然后，消费者拉取到消息时还会对tag做一遍比对，防止hash冲突导致拉取错误的数据。</p></li><li><p>SQL92：大致过程与第一种一样，不同的是在store层过滤数据执行的sql并用BloomFilter避免了每次都去执行</p></li></ol><blockquote><p> SQL92，是数据库的一个ANSI/ISO标准。它定义了一种语言（SQL）以及数据库的行为（事务、隔离级别等）</p></blockquote><h3 id="消息查询"><a href="#消息查询" class="headerlink" title="消息查询"></a>消息查询</h3><p>  消息查询有两种方式：</p><ol><li><p>按照MessageId查询，MessageId的长度总共有16字节，其中包含了消息存储主机地址（IP地址和端口）</p><blockquote><p>Client端从MessageId中解析出Broker的地址（IP地址和端口）和Commit Log的偏移地址<br>后封装成一个RPC请求后通过Remoting通信层发送（业务请求码：VIEW_MESSAGE_BY_ID）。Broker端走的是QueryMessageProcessor，读取消息的过程用其中的 commitLog offset 和 size 去 commitLog 中找到真正的记录并解析成一个完整的消息返回。</p></blockquote></li><li><p>按照MessageKey查询，基于IndexFile实现</p></li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><pre><code>  本章主要是基于GitHub文档中设计一节的内容的记录。大概了解了RocketMQ通信的结构及实现，不过关于通信的一些设计是基于netty实现，源码看得不是很 理解，就不在这里记录了。  关于负载均衡及分布式事务消息的设计，内容有点复杂，可能需要单独一章记录，就不在本章赘述了。</code></pre>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMq-架构</title>
      <link href="/2020/06/23/RocketMq1/"/>
      <url>/2020/06/23/RocketMq1/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  虽然用过RocketMQ，但是对他的架构及底层原理都不甚了解，所以阅读github的文档增加一些了解，这里做一个记录。</p><a id="more"></a><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>  RocketMQ的架构设计主要是四部分</p><ol><li>NameServer：路由注册中心，主要功能是管理Broker和路由信息</li><li>BrokerServer：负责消息的存储，投递，查询及高可用保证，是RocketMQ中最复杂的部分<br>为实现以上功能，他包含以下子模块：<ul><li>Remoting Module：整个Broker的实体，负责处理来自clients端的请求</li><li>Client Manager：负责管理客户端(Producer/Consumer)和维护Consumer的Topic订阅信息</li><li>Store Service：提供API接口处理消息存储到物理硬盘和查询功能</li><li>HA Service：高可用服务，提供Master Broker 和 Slave Broker之间的数据同步功能</li><li>Index Service：根据特定的Message key对投递到Broker的消息进行索引服务，以提供消息的快速查询</li></ul></li><li>Producer：消息的发布者</li><li>Consumer：消息的消费者</li></ol><h4 id="NameServer对Broker的管理"><a href="#NameServer对Broker的管理" class="headerlink" title="NameServer对Broker的管理"></a>NameServer对Broker的管理</h4><p>  NameServer接受Broker集群的注册信息并保留作为路由信息的数据，并通过心跳检测检查Broker的存活情况。<br>  心跳包由BrokerServer发出，NameServer负责接收及更新信息，如上报时间等。<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BrokerController.<span class="keyword">this</span>.registerBrokerAll(<span class="keyword">true</span>, <span class="keyword">false</span>, brokerConfig.isForceRegister());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            log.error(<span class="string">"registerBrokerAll Exception"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">1000</span> * <span class="number">10</span>, </span><br><span class="line">Math.max(<span class="number">10000</span>, Math.min(brokerConfig.getRegisterNameServerPeriod(), <span class="number">60000</span>)), </span><br><span class="line">TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// command：执行线程</span></span><br><span class="line"><span class="comment">// initialDelay：初始化延时</span></span><br><span class="line"><span class="comment">// period：两次开始执行最小间隔时间</span></span><br><span class="line"><span class="comment">// unit：计时单位</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, <span class="keyword">long</span> initialDelay,</span><br><span class="line">                                <span class="keyword">long</span> period, TimeUnit unit);</span><br></pre></td></tr></table></figure></p><p>  使用ScheduledExecutorService新建一个定时任务，间隔时间范围在10s~60s之间。</p><p>  然后NameServer会接收这个心跳包并保存，源码暂时没太理解，这里就不贴代码了。<br>  除了接受心跳包，NameServer还会启动一个定时任务检测BrokerServer的状态：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每10秒检测一次，对应心跳包发送的最小时间间隔</span></span><br><span class="line"><span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        NamesrvController.<span class="keyword">this</span>.routeInfoManager.scanNotActiveBroker();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">5</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测的具体逻辑</span></span><br><span class="line"><span class="comment">// private final static long BROKER_CHANNEL_EXPIRED_TIME = 1000 * 60 * 2;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scanNotActiveBroker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Iterator&lt;Entry&lt;String, BrokerLiveInfo&gt;&gt; it = <span class="keyword">this</span>.brokerLiveTable.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        Entry&lt;String, BrokerLiveInfo&gt; next = it.next();</span><br><span class="line">        <span class="comment">// 超过2分钟没有收到心跳则删除</span></span><br><span class="line">        <span class="keyword">long</span> last = next.getValue().getLastUpdateTimestamp();</span><br><span class="line">        <span class="keyword">if</span> ((last + BROKER_CHANNEL_EXPIRED_TIME) &lt; System.currentTimeMillis()) &#123;</span><br><span class="line">            RemotingUtil.closeChannel(next.getValue().getChannel());</span><br><span class="line">            it.remove();</span><br><span class="line">            log.warn(<span class="string">"The broker channel expired, &#123;&#125; &#123;&#125;ms"</span>, </span><br><span class="line">            next.getKey(), BROKER_CHANNEL_EXPIRED_TIME);</span><br><span class="line">            <span class="keyword">this</span>.onChannelDestroy(next.getKey(), next.getValue().getChannel());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Broker的消息存储"><a href="#Broker的消息存储" class="headerlink" title="Broker的消息存储"></a>Broker的消息存储</h4><p>  消息存储主要和以下三个文件有关：</p><ol><li><p>CommitLog：消息主体以及元数据的存储主体，存储Producer端写入的消息主体内容,消息内容不是定长的</p><blockquote><p>   单个文件大小默认1G ，文件名长度为20位，左边补零，剩余为起始偏移量，<br>   比如00000000000000000000代表了第一个文件，起始偏移量为0，文件大小为1G=1073741824；<br>   当第一个文件写满了，第二个文件为00000000001073741824，起始偏移量为1073741824，以此类推。消息主要是顺序写入日志文件，当文件满了，写入下一个文件。</p></blockquote></li><li><p>ConsumeQueue：消息消费队列，引入的目的主要是提高消息消费的性能，可以理解为toic的索引文件，能够提高基于topic对消息的查询效率</p><blockquote><p>   ConsumeQueue（逻辑消费队列）作为消费消息的索引，保存了指定Topic下的队列消息在CommitLog中的起始物理偏移量offset，消息大小size和消息Tag的HashCode值。<br>   consumequeue文件可以看成是基于topic的commitlog索引文件，故consumequeue文件夹的组织方式如下：topic/queue/file三层组织结构，<br>   具体存储路径为：$HOME/store/consumequeue/{topic}/{queueId}/{fileName}。<br>   同样consumequeue文件采取定长设计，每一个条目共20个字节，分别为8字节的commitlog物理偏移量、4字节的消息长度、8字节tag hashcode，单个文件由30W个条目组成，可以像数组一样随机访问每一个条目，每个ConsumeQueue文件大小约5.72M。</p></blockquote></li><li><p>IndexFile：提供了一种可以通过key或时间区间来查询消息的方法</p><blockquote><p>   Index文件的存储位置是：$HOME \store\index${fileName}，<br>   文件名fileName是以创建时的时间戳命名的，固定的单个IndexFile文件大小约为400M，一个IndexFile可以保存 2000W个索引，IndexFile的底层存储设计为在文件系统中实现HashMap结构，故rocketmq的索引文件其底层实现为hash索引。</p></blockquote><p>CommitLog是数据实际的存储和数据持久化的方式，保证了消息不会丢失。而ConsumeQueue和IndexFile则是基于CommitLog的数据建立的索引来优化消息消费和查询的效率。<br>针对三种文件，org.apache.rocketmq.store包下也有对应的同名类进行配置管理，就不在本章详细解析了。</p></li></ol><h3 id="部署架构"><a href="#部署架构" class="headerlink" title="部署架构"></a>部署架构</h3><ul><li>NameServer：几乎无状态节点，可集群部署，节点之间无任何信息同步</li><li>BrokerServer：多主从结构，Master与Slave 的对应关系通过指定相同的BrokerName，不同的BrokerId 来定义，BrokerId为0表示Master，非0表示Slave。每个Broker与NameServer集群中的所有节点建立长连接，定时注册Topic信息到所有NameServer</li><li>Producer：完全无状态，可集群部署；与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer获取Topic路由信息，并向提供Topic 服务的Master建立长连接，且定时向Master发送心跳</li><li>Consumer：与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer获取Topic路由信息，并向提供Topic服务的Master、Slave建立长连接，且定时向Master、Slave发送心跳</li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><pre><code>  本章内容是阅读RocketMQ文档后总结的一些概念和知识点。简单的看了一下NameServer和Broker的部分源码。源码内容较复杂，只能一个个模块拆开慢慢看了。  经过本章的总结，算是对RocketMQ有了基础的认识，之后再详细的了解吧。</code></pre><blockquote><p>下一章 <a href="https://rel-fly.com/2020/06/24/RocketMq2/">&lt;RocketMQ-设计&gt;</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThinkingInJava-8</title>
      <link href="/2020/06/17/ThinkingInJava8/"/>
      <url>/2020/06/17/ThinkingInJava8/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  String应该是Java中较为特殊的对象。一方面他的使用场景非常多，其丰富的方法使得String类型的数据非常容易<br>  处理。另一方面，他的不可变的特性也让其区分于其他对象。怎么理解String的不可变，以及他与StringBuilder和StringBuffer的区别等问题也是在面试中会问到的问题。</p><a id="more"></a><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>   本书第十三章，围绕String，介绍了String的不可变特性，StringBuilder对某些场景下String操作的优化，及正则表达式等内容。</p><h4 id="不可变的String"><a href="#不可变的String" class="headerlink" title="不可变的String"></a>不可变的String</h4><p>  作为我们用到的最多的一个对象之一，他的不可变让其显得有点特殊。对于参数的类型可能会这样区分：基本类型，String类型，集合类型，其他对象类型。<br>  那么如何理解String的不可变呢？</p><p>  首先从源码上看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 存放字符串数据的char数组.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br></pre></td></tr></table></figure><p>  可以看到，String类从以下三个方面保证了不可变：</p><ol><li>类不可继承，这就防止了子类的修改</li><li>数组value用final修饰，表示指向数组的引用值不可变(但是数组本身是可变的)</li><li>数组value用private修饰，避免外部访问修改数组，而String类本身也没有修改数组的操作，这就保证了数组的不变</li></ol><p>  综上三点是保证String不可变的实现逻辑。<br>  然后我们看看，String的不可变为我们带来什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    String s = <span class="string">"aaa"</span>;</span><br><span class="line">    ClassChild cc = <span class="keyword">new</span> ClassChild(i, s);</span><br><span class="line">    stringTest(i, s, cc);</span><br><span class="line">    logger.info(<span class="string">"result1:&#123;&#125;,&#123;&#125;,&#123;&#125;"</span>, i, s, cc);</span><br><span class="line">    stringTest2(i, s, cc);</span><br><span class="line">    logger.info(<span class="string">"result2:&#123;&#125;,&#123;&#125;,&#123;&#125;"</span>, i, s, cc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stringTest</span><span class="params">(<span class="keyword">int</span> i, String param, ClassChild object)</span> </span>&#123;</span><br><span class="line">    i = <span class="number">2</span>;</span><br><span class="line">    param = <span class="string">"bbb"</span>;</span><br><span class="line">    object.a = <span class="number">2</span>;</span><br><span class="line">    object.b = <span class="string">"bbb"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stringTest2</span><span class="params">(<span class="keyword">int</span> i, String param, ClassChild object)</span> </span>&#123;</span><br><span class="line">    i = <span class="number">3</span>;</span><br><span class="line">    String newStr = <span class="string">"ccc"</span>;</span><br><span class="line">    param = newStr;</span><br><span class="line">    ClassChild cc = <span class="keyword">new</span> ClassChild(<span class="number">3</span>, <span class="string">"ccc"</span>);</span><br><span class="line">    object = cc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// result1:1,aaa,&#123;"a":2,"b":"bbb"&#125;</span></span><br><span class="line"><span class="comment">// result2:1,aaa,&#123;"a":2,"b":"bbb"&#125;</span></span><br></pre></td></tr></table></figure><p>  可以看到，同样是对象，传参的是引用值，String类型的原对象不变，而普通对象的原值变了。<br>  对于给String类型重新赋值的操作,其实可以理解为新建了一个String对象然后将引用改为指向这个新对象。就如方法<em>stringTest2()</em> 的操作一样。</p><p>  另一点，已经定义过的字符串都会放在字符串常量池里。如果新建一个String对象，会首先去池里找有没有现成的，有则直接指向他，没有才会创建并放入常量池，这节省了大量的内存空间。</p><h4 id="StringBuilder和StringBuffer"><a href="#StringBuilder和StringBuffer" class="headerlink" title="StringBuilder和StringBuffer"></a>StringBuilder和StringBuffer</h4><p>  StringBuilder和StringBuffer都继承了抽象类AbstractStringBuilder。两者是为了在某些场景下替换String的使用，作为一种优化方案。<br>  他们的不同之处只在于StringBuffer的方法都用synchronized修饰，所以是线程安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 存储字符的数组</span></span><br><span class="line">    <span class="keyword">char</span>[] value;</span><br></pre></td></tr></table></figure><p>  可以看到存放字符串的数组并不是private final，这就是StringBuiler，StringBuffer与String的最大区别，前者是可变的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    sb.append(<span class="number">1</span>);</span><br><span class="line">    logger.info(<span class="string">"result:&#123;&#125;"</span>, sb);</span><br><span class="line">    sbTest(sb);</span><br><span class="line">    logger.info(<span class="string">"result:&#123;&#125;"</span>, sb);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sbTest</span><span class="params">(StringBuilder sb)</span> </span>&#123;</span><br><span class="line">    sb.append(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// result:1</span></span><br><span class="line"><span class="comment">// result:12</span></span><br></pre></td></tr></table></figure><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>  正则表达式是过滤字符串和格式校验等方面极好用高效的工具。<br>  正则表达式通过通配符构建匹配规则，然后针对目标字符串进行匹配处理。这里就不详细叙述他的规则了，简单介绍下Java中的用法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String regText = <span class="string">"^[1-5]&#123;1,3&#125;$"</span>;</span><br><span class="line">String checkText1 = <span class="string">"1111"</span>;</span><br><span class="line">String checkText2 = <span class="string">"33"</span>;</span><br><span class="line">String checkText3 = <span class="string">"888"</span>;</span><br><span class="line">logger.info(<span class="string">"result1:&#123;&#125;"</span>, Pattern.matches(regText, checkText1));</span><br><span class="line">logger.info(<span class="string">"result2:&#123;&#125;"</span>, Pattern.matches(regText, checkText2));</span><br><span class="line">logger.info(<span class="string">"result3:&#123;&#125;"</span>, Pattern.matches(regText, checkText3));</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// result1:false</span></span><br><span class="line"><span class="comment">// result2:true</span></span><br><span class="line"><span class="comment">// result3:false</span></span><br></pre></td></tr></table></figure><p>  上面就是一个很简单使用正则校验字符串的例子。<br>  当我们对一些复杂的正则表达式很难快速理解的时候，可以借助正则表达式的可视化工具，这里推荐<em>regexper</em>。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><pre><code>  对于String，我们用得很多，但不一定理解的很深。String最重要的就是理解他的不可变，会有什么效果，能有什么好处，什么时候用StringBuilder和StringBuffer等。  本章只是着重记录了对String不可变的理解，其实String的源码包括StringBuilder及StringBuffer的源码都很值得一看。而且阅读源码才能够深入理解String。所以这里就简单的记录下，更多内容放在之后对其源码解读上吧。</code></pre><blockquote><p>下一章 <a href="https://rel-fly.com/2020/06/19/ThinkingInJava9/">&lt;ThinkingInJava-9&gt;</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> ThinkingInJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ThinkingInJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThinkingInJava-7</title>
      <link href="/2020/06/15/ThinkingInJava7/"/>
      <url>/2020/06/15/ThinkingInJava7/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  错误是代码难以避免的问题。编译器的错误可以直接修改代码，运行期的错误就需要将其传递到其他能处理的地方，这时候就要用到Java的异常机制。</p><a id="more"></a><h3 id="通过异常处理错误"><a href="#通过异常处理错误" class="headerlink" title="通过异常处理错误"></a>通过异常处理错误</h3><p>  本书第十二章，主要讲述了Java异常及异常处理的相关内容。</p><h4 id="Java异常"><a href="#Java异常" class="headerlink" title="Java异常"></a>Java异常</h4><p>  Java异常都继承自Throwable，然后其下分为Exception和Error两个子类</p><ol><li><p>Error(错误)<br>Error指一些无法恢复或不能捕捉的严重错误，此类错误会导致程序中断。</p></li><li><p>Exception(异常)<br>Exception又分为运行时异常和非运行时异常</p><ul><li><p>运行时异常<br>继承自Exception子类RuntimeException的异常类，可以被捕捉处理，也可以不处理。<br>常见的包括：NullPointerException，IndexOutOfBoundsException等</p></li><li><p>非运行时异常<br>继承自Exception的非RuntimeException的异常类，统称为非运行时异常。<br>这种异常必须要捕捉处理，否则编译无法通过。<br>常见的如：IOException</p></li></ul></li></ol><h4 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h4><ol><li><p>抛出异常<br>异常抛出的关键字有两个throw和throws，他们的区别很大：<br>throw：强调的是抛出异常的这个动作，只在方法体中使用<br>throws：是对方法可能抛出异常的声明，相当于告诉其他开发者这个方法可能抛出什么异常，需要处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手动抛出异常，程序中止</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> MyException(<span class="string">"10000"</span>,<span class="string">"error"</span>);</span><br><span class="line"><span class="comment">// 声明方法可能抛出的异常，可以声明多个以逗号分隔</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="keyword">throws</span> MyException, IOException</span>;</span><br></pre></td></tr></table></figure></li><li><p>捕获处理异常</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;<span class="comment">// 执行逻辑</span></span><br><span class="line">    test.method(<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(MyException e)&#123;<span class="comment">// 异常捕捉</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException ioe)&#123;<span class="comment">// 方法抛出的所有异常都要捕捉</span></span><br><span class="line">    System.out.println(<span class="string">"不同的处理"</span>);</span><br><span class="line">    ioe.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 最后执行的代码块，无论是否发生异常都会执行，通常用来执行一些资源的关闭逻辑</span></span><br><span class="line">    System.out.println(<span class="string">"最后执行"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    test.method(<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(MyException | IOException e)&#123;<span class="comment">// 不同异常的处理逻辑相同则可以简写</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"最后执行"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// try-with-resource语法，声明的资源会自动关闭，无需在finally手动执行</span></span><br><span class="line"><span class="keyword">try</span> (BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">""</span>))) &#123;</span><br><span class="line">     br.readLine();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  用catch捕捉异常可以通过捕捉对应异常的父类异常，例如上述例子中可以这么写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;<span class="comment">// 执行逻辑</span></span><br><span class="line">    test.method(<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;<span class="comment">// 异常捕捉</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 最后执行的代码块，无论是否发生异常都会执行，通常用来执行一些资源的关闭逻辑</span></span><br><span class="line">    System.out.println(<span class="string">"最后执行"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>    <p>  因为Exception是其他异常的父类，所以可以捕捉到方法抛出的两种异常。当然，虽然这样看上去更加<br>  简洁，但是异常信息就不够明确，所以一般情况不建议这样做。<br>  因此，catch异常的顺序也需要特别注意，如果把大的异常(即父类异常)放到前面，由于对异常的匹配<br>  寻找是按顺序来的，后面的小异常可能永远不会派上用场。</p><h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><p>  除了Java已经定义好的异常类，我们也可以根据自己的需求自定义异常类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义异常需要继承Exception或其子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Exception提供了不同的有参构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String code, String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(msg);</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重写getMessage()方法以实现定制化的信息输出</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"MyException detail:"</span> + code + <span class="string">"-"</span> + msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="异常的栈轨迹"><a href="#异常的栈轨迹" class="headerlink" title="异常的栈轨迹"></a>异常的栈轨迹</h4><p>  通常我们用<em>e.printStackTrace();</em>输出异常信息的时候可以看到一行行的方法地址。这就是异常的栈轨迹，表示异常一步步抛出到最外面的轨迹。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">float</span> f)</span> </span>&#123;</span><br><span class="line">    InterfaceTest test = <span class="keyword">new</span> Product();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MyException();</span><br><span class="line">    &#125;<span class="keyword">catch</span>(MyException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">for</span>(StackTraceElement ste:e.getStackTrace())&#123;</span><br><span class="line">            System.out.println(ste.getMethodName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">numberTwo</span><span class="params">()</span></span>&#123;method(<span class="number">1</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">numberThree</span><span class="params">()</span></span>&#123;numberTwo();&#125;</span><br></pre></td></tr></table></figure><p>  比如上面这样层层调用，通过<em>e.getStackTrace()</em>获取栈轨迹的数组，然后逐个输出，就能看到如下结果</p><pre><code>methodnumberTwonumberThreemain</code></pre><p>  能够看到每一步调用的方法。</p><h4 id="异常链"><a href="#异常链" class="headerlink" title="异常链"></a>异常链</h4><p>  如果捕捉异常后，抛出新的异常，那么会丢失原异常的信息。<br>  这时可以通过Exception的构造方法保留原异常的信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Exception</span><span class="params">(String message, Throwable cause)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(message, cause);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  cause参数用来表示原始异常，可以通过这种方法将不同的异常信息串联起来，也被称作异常链。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><pre><code>  异常不可避免，但是通过抛出/捕捉处理我们可以自由的控制异常。将他抛到我们需要处理的地方，或者直接捕捉进行处理。这使得代码逻辑能够按照我们所设想的逻辑执行，而不会因为突如其来的异常导致程序中止，偏离了我们的预想。  另一方面，对异常的信息输出也很关键了。良好的输出代表着代码有效的反馈，能够帮助开发者快速的定位问题，然后决定如何修改优化。</code></pre><blockquote><p>下一章 <a href="https://rel-fly.com/2020/06/17/ThinkingInJava8/">&lt;ThinkingInJava-8&gt;</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> ThinkingInJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ThinkingInJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThinkingInJava-6</title>
      <link href="/2020/06/14/ThinkingInJava6/"/>
      <url>/2020/06/14/ThinkingInJava6/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  集合是Java中较为重要的一个模块。也是我们日常使用较多的功能。容器的种类繁多，各有特点，所以只有了解<br>  掌握好各个容器的特点才能在适合的场景使用正确的容器。<br>  本章涉及的都是常用的同步容器，如ArrayList,LinkedList,HashMap等。</p><a id="more"></a><h3 id="持有对象"><a href="#持有对象" class="headerlink" title="持有对象"></a>持有对象</h3><p>  本书第十一章，从对象的保存引入集合概念。介绍了Java中常用的几大集合类型即迭代器等工具的使用。</p><h4 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h4><pre><code>独立元素的序列，其下又分为List，Queue，Set三大类。</code></pre><h5 id="List"><a href="#List" class="headerlink" title="List"></a>List</h5><pre><code>List是一个按照插入顺序排序的集合，常用的有ArrayList和LinkedList。</code></pre><ol><li><p>ArrayList：基于数组结构的集合，优势在于随机访问，但是新增和删除操作较慢。可以参考<a href="https://rel-fly.com/2020/05/26/arrayList1/">&lt;ArrayList(jdk1.8)&gt;</a></p></li><li><p>LinkedList：实现List接口的同时还实现了Deque(Queue的子接口)，所以可以用作栈，队列等结构。其基于双向循环链表，优势在于顺序访问及代价较低的新增和删除操作，但是随机访问较慢。</p></li></ol><h5 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h5><pre><code>  Queue的大多实现遵循先进先出的规则，事物的放入顺序与取出顺序一样。因为其特点，在并发中起到了非常重要的作用。</code></pre><ol><li>PriorityQueue：优先队列，其队列规则是下一个弹出的元素是优先级最高的而不是等待时间最长(先进先出即弹出等待时间最长的)。</li></ol><h5 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h5><pre><code>非重复元素集合，常用作元素在集合中存在性的判断。</code></pre><ol><li><p>HashSet：底层基于HashMap存储数据，实现Set接口，所以具有Set集合的特点，不接受重复元素。其查询效率较高。</p></li><li><p>TreeSet：与HashSet不同的是实现了NavigableSet(SortedSet的子接口)，元素处于排序状态。</p></li><li><p>LinkedHashSet：以插入顺序保存元素。</p></li></ol><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><pre><code>Map是一种对象与对象关联的设计，键值对类型能够让基于key的查询保持很高的效率。</code></pre><ol><li><p>HashMap：基于数组+链表/红黑树的结构。因为键值对的特点，根据key值的查询较快，新增删除如果涉及到扩容和链表/树结构的变化代价会较大。具体可参考<a href="https://rel-fly.com/2020/05/30/hashMap1/">&lt;HashMap(jdk1.8)&gt;</a></p></li><li><p>TreeMap：基于红黑树的结构。保持key始终处于排序状态。</p></li><li><p>LinkedHashMap：HashMap的子类，在HashMap的结构基础上增加了一个双向链表记录元素插入顺序。所以他的key保持插入顺序排序，同时查询速度也很快。</p></li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><pre><code>  哪怕只是同步集合，其实内容也比较多。相对来说，自己对集合的使用还是较为死板。像List可能就无脑用ArrayList了，这点需要在实际开发中注意。而且还有对并发集合的选择，正确的选择才能有效提高代码效率和安全性。  书中还提到了用其他的Collection对象来完成初始化，Arrays.asList()的使用，以及集合与迭代器的使用等。这些留待之后单独的一一研究记录。本章只是单纯的对常用同步集合做了一个罗列，也准备之后挨个以源码解读的方式记录。</code></pre><blockquote><p>下一章 <a href="https://rel-fly.com/2020/06/15/ThinkingInJava7/">&lt;ThinkingInJava-7&gt;</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> ThinkingInJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ThinkingInJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThinkingInJava-5</title>
      <link href="/2020/06/11/ThinkingInJava5/"/>
      <url>/2020/06/11/ThinkingInJava5/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  在介绍完基本的类和相关设计方法如继承，组合后，就开始扩展类的定义了。<br>  抽象类和接口是普通类向抽象化进一步延申的类型，两者的出现使得继承这种关系更加灵活且更容易扩展。<br>  而内部类则是与接口一起，解决了Java无法多继承的问题。变相实现了Java的多继承。</p><a id="more"></a><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>  本书第九章，主要介绍了抽象类和接口的使用。</p><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><pre><code>定义：使用abstract关键字修饰的类，其特点是无法被实例化，所以只能用来被继承。抽象方法：1.抽象类中可以没有抽象方法，但有抽象方法的一定是抽象类         2.抽象方法没有方法体，需要由抽象类的非抽象类子类重写         3.抽象方法不能定义为private，因为无法被继承，与第二点相悖</code></pre><p>  抽象类的出现使得开发者不必关心父类中方法的实现细节，只需要定义某一类型的行为。然后在各个子类中重写方法，定义具体的实现逻辑。</p><h4 id="接口-1"><a href="#接口-1" class="headerlink" title="接口"></a>接口</h4><pre><code>定义：使用interface关键字修饰，其特点是：      1. 无法实例化，没有构造方法      2. 接口中的方法都被隐式的指定为public abstract 且无法修改，同样必须在其子类中被重写      3. 接口的属性都被隐式的指定为public static final 且无法修改      4. 接口中不能含有代码块及静态方法      5. 用implements表示实现接口，并且可以实现多个接口，用逗号分隔</code></pre><p>  可以看到，相比抽象类，接口是一种更抽象化的类型。<br>  抽象类还保留有类的一些结构，而接口则可以说是完全的抽象。而且不受单继承的限制，这使得对类结构的设计更加灵活，可扩展。</p><h4 id="同名方法的冲突"><a href="#同名方法的冲突" class="headerlink" title="同名方法的冲突"></a>同名方法的冲突</h4><p>  书中提到了一种情况，实际开发中因为开发规范等没有遇到过，所以自己试了下。<br>  问题就是，一个类继承的父类和实现的接口有同名的方法，会怎么样？<br>  这里就不展示代码了，直接说结果：</p><pre><code>1. 同名且参数列表不同   没有冲突，可以各自重写2. 同名，参数列表相同，返回值也相同   可以理解为当作了一个方法。如果父该方法是抽象方法，只用也只能重写一次   (要不然两个一样的方法妥妥的冲突，这点很好理解)。如果不是抽象方法，可不用重写，因为父类已经实现   了方法逻辑3. 同名，参数列表相同，返回值不同   会有冲突，你对其中一个方法的重写也被视作对另一个方法的重写，但是返回类型不一样就会报错。两个都   重写，不符合重载方法的规则，也会报错。</code></pre><p>  这个问题，日常开发应该不会遇到，而且也应该避免这种同名方法，很容易带来混淆。</p><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>  本书第十章，在认识了抽象类，接口后，开始介绍另一种类-内部类。</p><h4 id="不同的内部类"><a href="#不同的内部类" class="headerlink" title="不同的内部类"></a>不同的内部类</h4><ol><li><p>成员内部类<br>最常见的内部类定义，相当于外部类的成员，拥有外部类所有资源的访问权限。</p></li><li><p>局域内部类<br>定义于类方法或作用域中的内部类，只在包含他的方法和作用域中有效。属于方法而不是类的一部分。</p></li><li><p>匿名内部类<br>应该是比较常用的一种内部类定义。主要是在父类或接口存在的情况下，创建一个继承该父类或实现接口的子类对象，并实现对应方法。<br>这种方式可以避免单独创建类，如果不考虑类的复用，那么这种写法能节省很多代码量。</p></li><li><p>静态内部类(嵌套类)<br>如果不需要内部类对象与其外围类有联系，则可以声明为static。<br>静态内部类的创建不需要外围类的对象，且不能从静态内部类的对象中访问非静态的外围类对象。</p></li></ol><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExternalClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 外围类对内部类的创建及访问</span></span><br><span class="line">        InsideClass ic = <span class="keyword">new</span> InsideClass();</span><br><span class="line">        ic.show();</span><br><span class="line">        InsideClass2 ic2 = <span class="keyword">new</span> InsideClass2();</span><br><span class="line">        ic2.show();</span><br><span class="line">        InsideClass2.show2();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 局域内部类</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">InsideClass3</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 可以访问外围类成员</span></span><br><span class="line">                System.out.println(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只能在方法内访问到</span></span><br><span class="line">        InsideClass3 ic3 = <span class="keyword">new</span> InsideClass3();</span><br><span class="line">        ic3.method();</span><br><span class="line">        <span class="comment">// 匿名内部类</span></span><br><span class="line">        <span class="comment">// 新建一个实现接口InterfaceTest的子类的对象</span></span><br><span class="line">        <span class="keyword">new</span> InterfaceTest() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"2"</span>);</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">InsideClass3</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"```"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        InsideClass3 ic = <span class="keyword">new</span> InsideClass3();</span><br><span class="line">        ic.method();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员内部类 不能创建static属性或方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsideClass</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 可以访问外部类的所有资源</span></span><br><span class="line">            a = <span class="number">1</span>;</span><br><span class="line">            b = <span class="number">2</span>;</span><br><span class="line">            method1();</span><br><span class="line">            method2();</span><br><span class="line">            ExternalClass.<span class="keyword">this</span>.method1();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InsideClass2</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 只能访问外部类的静态资源</span></span><br><span class="line">            b = <span class="number">2</span>;</span><br><span class="line">            method2();</span><br><span class="line">            System.out.println(<span class="string">"InsideClass2"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            b = <span class="number">2</span>;</span><br><span class="line">            method2();</span><br><span class="line">            System.out.println(<span class="string">"InsideClass2"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成员内部类的对象新建方法</span></span><br><span class="line"><span class="comment">// 需要先取得外围类的对象再新建其内部类对象</span></span><br><span class="line">ExternalClass.InsideClass ic = <span class="keyword">new</span> ExternalClass().<span class="keyword">new</span> InsideClass();</span><br><span class="line"><span class="comment">// 静态内部类的对象新建方法： </span></span><br><span class="line">ExternalClass.InsideClass2 ic2 = <span class="keyword">new</span> ExternalClass.InsideClass2();</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><pre><code>    接口，抽象类，内部类，这三者为类的设计提供了更多的可能和思路。特别是接口和内部类，变相实现了Java的多继承。    内部类感觉要比接口和抽象类复杂一些。内部类与外围类相互独立，一个类可以建立多个内部类来继承不同的类或实现不同的接口已突破单一继承的限制。另一方面，内部类也是可以被继承的，这在增加了更多可能的同时，也会增加类关系的复杂度。所以还是要依据实际业务场景去设计(HashMap和LinkedHashMap应该算是个不错的参考对象)。</code></pre><blockquote><p>下一章 <a href="https://rel-fly.com/2020/06/14/ThinkingInJava6/">&lt;ThinkingInJava-6&gt;</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> ThinkingInJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ThinkingInJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThinkingInJava-4</title>
      <link href="/2020/06/09/ThinkingInJava4/"/>
      <url>/2020/06/09/ThinkingInJava4/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  类的关系，用来概括七，八两章的内容应该足以。从第七章的继承，组合到第八章的多态。Java中能够为类设计的关系结构初步展现出来。</p><a id="more"></a><h3 id="复用类"><a href="#复用类" class="headerlink" title="复用类"></a>复用类</h3><p>  本书的第七章，主要内容是关于类的复用。<br>  类的复用能够减少代码的重复，并且使得整体更具结构化，而不是杂乱无章。<br>  复用主要依靠类的组合和继承两种方式，组合倾向于使用现有类的功能，继承则是完整复用了现有类的结构(属性，方法等)。</p><h4 id="组合和继承"><a href="#组合和继承" class="headerlink" title="组合和继承"></a>组合和继承</h4><p>  组合是将一个类的实例作为自己的属性，然后通过这个实例复用他的一些方法。<br>  继承则可以理解为直接复用了父类的结构，在此基础上做了扩展(当然，也可以重写父类的方法)。</p><p>  对于复用类的初始化两者的区别：</p><pre><code>组合关系：复用类作为一个属性，对于他的初始化我们可以选择在定义时初始化，在构造方法中初始化，或者在         使用到的时候才去完成初始化。继承关系：在子类初始化之前完成父类的初始化。并且属于一种隐式操作，从外表来看，我们只是初始化了一个         子类的实例。其实这个子类实例内部包含了一个父类实例。</code></pre><p>  基于初始化的区别可以看出，组合更像是为复用类预留了一个位置，我需要用你的时候就会初始化。而继承，父类的实例成了子类实例的一个影子，相互关系更加紧密。<br>  当然，继承更重要的一个作用是多态。子类对象可以当作他的父类处理，即<em>向上转型</em>。所以如果不是必须使用向上转型，还是推荐使用组合。</p><h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><p>  代理属于继承和组合的中间选择，结构上和组合一样，将复用类当作自己的属性，但方法与复用类一致，处理则是直接调用了复用类的方法。<br>  例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassChild</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ClassOther co;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        co.add();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">minus</span><span class="params">()</span></span>&#123;</span><br><span class="line">        co.minus();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   可以简单理解为为了隐藏复用类，套了一个壳子。</p><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p>  通常来说，final的修饰的含义是”不可改变”。具体到属性，方法，类上又有些差别。</p><ol><li>属性<br>对于基本类型的修饰，表示该基本类型的值，不可更改。但如果是一个对象而非基本类型的话，<br>因为修饰的实际上是对象的引用，所以其实际意义是这个引用不可再指向其他对象，但不影响对象自身的修改。</li><li>方法<br>对于方法的修饰可以在继承时禁止方法被重写</li><li>类<br>final类不可被继承</li></ol><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>  本书的第八章，多态。</p><h4 id="后期绑定"><a href="#后期绑定" class="headerlink" title="后期绑定"></a>后期绑定</h4><p>  后期绑定是确保多态能正确执行的关键之一。编译器不关心对象的具体类型，直到运行时才能判断对象的类型，从而调用正确的方法体。<br>  Java中除了static，final，private方法外，都是后期绑定的。</p><h4 id="协变返回类型"><a href="#协变返回类型" class="headerlink" title="协变返回类型"></a>协变返回类型</h4><p>  子类重写的方法的返回类型可以是对应父类方法中返回类型的子类</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><pre><code>  这两章的内容其实较为单一。类的继承占了很大的篇章。这也是因为继承是Java中最常用最重要的行为之一。良好的继承关系能够提升代码的复用性，提高代码的阅读性，设计出精妙的数据结构。当然，就像第七章中表达的那样，继承某种程度加强了代码的耦合性。所以，不是必须使用多态，更推荐组合这种更加灵活，更容易扩展的结构。  关于多态，其实书中举了很多使用多态的例子，包括一些问题，例如静态方法，对类数据域的访问等不过实际开发中由于相关开发规范，并不会遇到这些问题，所以没有记录。</code></pre><blockquote><p>下一章 <a href="https://rel-fly.com/2020/06/11/ThinkingInJava5/">&lt;ThinkingInJava-5&gt;</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> ThinkingInJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ThinkingInJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThinkingInJava-3</title>
      <link href="/2020/06/07/ThinkingInJava3/"/>
      <url>/2020/06/07/ThinkingInJava3/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  来到本书第五，六章，在介绍完Java操作符及一些关键字后，开始介绍一些机制。如：类的初始化，垃圾回收清理，访问权限等。这些都是有助于我们更好了解代码执行过程的知识点。</p><a id="more"></a><h3 id="初始化与清理"><a href="#初始化与清理" class="headerlink" title="初始化与清理"></a>初始化与清理</h3><p>  本书的第五章，主要介绍了构造器，方法的重载，类初始化的顺序及对象的回收等。关于对象的回收想放到Java虚拟机的总结中，所以这里没有记录。主要就方法重载和类初始化顺序记录一下。</p><h4 id="涉及基本类型的重载"><a href="#涉及基本类型的重载" class="headerlink" title="涉及基本类型的重载"></a>涉及基本类型的重载</h4><p>  方法的重载是多个方法名一样，参数列表不一样的方法。参数列表不一样包括类型和顺序，例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> a, String b)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// ·····</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">method</span><span class="params">(String a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// ·····</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  而如果涉及基本类型的重载，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">method(<span class="number">5</span>);<span class="comment">// method1</span></span><br><span class="line">method(<span class="number">5f</span>);<span class="comment">// method1</span></span><br><span class="line">method(<span class="number">5</span>d);<span class="comment">// method2</span></span><br><span class="line">method(<span class="string">'1'</span>);<span class="comment">// method1</span></span><br><span class="line"><span class="comment">// method1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">float</span> f)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"float"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// method2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">double</span> d)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"double"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>  当入参为基本类型时，没指定具体类型的情况下，常量数值会被当作int处理。而如果这时没有对应int类型入参的方法，就会提升数据类型(例如这里的method(5)就提升为float类型)。而char类型则是当没有对应类型的方法时，被当作int处理。</code></pre><h4 id="初始化的顺序"><a href="#初始化的顺序" class="headerlink" title="初始化的顺序"></a>初始化的顺序</h4><p>  第二章中有提到static关键字。而在一个类中，如果有静态代码块等，其初始化顺序是怎样的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassParent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">"静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"静态方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ClassParent() &#123;</span><br><span class="line">        System.out.println(<span class="string">"构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassChild</span> <span class="keyword">extends</span> <span class="title">ClassParent</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        b = <span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">"child-静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"child-代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"child-静态方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ClassChild() &#123;</span><br><span class="line">        System.out.println(<span class="string">"child-构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   如上两个类，当创建类的实例或者直接调用类的静态方法，他的初始化顺序如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ClassChild cc = <span class="keyword">new</span> ClassChild();</span><br><span class="line"><span class="comment">// 输出为：</span></span><br><span class="line"><span class="comment">//静态代码块</span></span><br><span class="line"><span class="comment">//child-静态代码块</span></span><br><span class="line"><span class="comment">//代码块</span></span><br><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="comment">//child-代码块</span></span><br><span class="line"><span class="comment">//child-构造方法</span></span><br><span class="line"></span><br><span class="line">ClassChild.function();</span><br><span class="line"><span class="comment">// 输出为：</span></span><br><span class="line"><span class="comment">//静态代码块</span></span><br><span class="line"><span class="comment">//child-静态代码块</span></span><br><span class="line"><span class="comment">//child-静态方法</span></span><br></pre></td></tr></table></figure><pre><code>  可以看出，静态代码块总是优先加载，在有父类的情况下，也是按照父类-&gt;子类的顺序先把静态代码块加载完。然后才是加载各自的代码块和构造方法。而直接调用静态方法，也会先初始化父类及子类的静态代码块。但因为没有涉及类的实例化，所以不会有代码块和构造方法的初始化。</code></pre><h3 id="访问权限控制"><a href="#访问权限控制" class="headerlink" title="访问权限控制"></a>访问权限控制</h3><p>  本书第六章，主要介绍Java访问权限的相关知识。</p><h4 id="访问权限的类型"><a href="#访问权限的类型" class="headerlink" title="访问权限的类型"></a>访问权限的类型</h4><pre><code>1. public：接口访问权限，对public修饰的变量，方法的访问没有限制2. 默认访问：包访问权限，不加任何修饰词的话，默认是同一个包下才有访问权限3. protected：继承访问权限，首先会提供包访问权限，其次，如果子类继承了某个类，那么可以不在同              一个包下也能访问父类中用protected修饰的资源4. private：类访问权限，只能在本类中被访问</code></pre><img src="/image/ThinkingInJava/ThinkingInJava3-1.png" class="" title="访问权限"><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><pre><code>  这两章主要介绍了Java类相关的知识点。类的初始化，构造方法的一些注意点。基础类型参数的重载方法是以前没注意到的，所以记录了下。类的初始化顺序，也是相对重要的知识点，静态代码块的优先级是最高的，所以也常用作一个默认值设置等初始化操作。</code></pre><blockquote><p>下一章 <a href="https://rel-fly.com/2020/06/09/ThinkingInJava4/">&lt;ThinkingInJava-4&gt;</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> ThinkingInJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ThinkingInJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThinkingInJava-2</title>
      <link href="/2020/06/07/ThinkingInJava2/"/>
      <url>/2020/06/07/ThinkingInJava2/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  《Thinking in Java(第四版)》的第三，四章主要介绍了Java中基本的操作符及控制执行流程的相关关键字。</p><a id="more"></a><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><p>  本书的第三章-操作符，主要介绍了Java中使用到的各种操作符。</p><pre><code>1. 算术运算符：+, -, *, /, %2. 关系操作符：&gt;, &lt;, ==, &gt;=, &lt;=3. 逻辑操作符：&amp;&amp;, ||, !4. 直接常量的类型指定：l L, f F, d D, 0x[n](16进制), 0[n](8进制) 5. 按位操作符：&amp;, |, ~6. 移位操作符：&gt;&gt;, &lt;&lt;, &gt;&gt;&gt;7. 条件操作符：? :</code></pre><p>  操作符比较好理解，需要注意的几点：</p><pre><code>1. 操作符的顺序，如果不能确定建议使用()控制。这样也能提高代码的可读性2. 逻辑操作符有短路的特性3. 按位操作符，移位操作符都是针对二进制的操作，其中对char,byte,short类型的   数据进行移位操作时会先转为int类型，结果也是int</code></pre><p>  关于按位操作符和移位操作符的具体信息可以参考<a href="https://rel-fly.com/2020/06/02/bitwiseOperator/">&lt;Java-位运算符&gt;</a></p><h4 id="直接常量"><a href="#直接常量" class="headerlink" title="直接常量"></a>直接常量</h4><p>  某些时候，编译器可能无法确定一些直接常量的类型，就需要用到一些字符辅助。<br>  例如：Java中会将指数当作double处理，那么对于<em>float f = 1e-10;</em>，如果不使用<em>f</em> 作为后缀即<em>1e-10f</em>。就会报错，告诉我们需要将double转为float。</p><h3 id="控制执行流程"><a href="#控制执行流程" class="headerlink" title="控制执行流程"></a>控制执行流程</h3><p>  本书的第四章，主要介绍判断，循环，跳转等流程控制的相关关键字。</p><h4 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h4><p>  加强型for循环，作为普通for循环的替代，因为不必创建int变量对访问项计数，提高了代码的可读性。<br>  但也正是因为不用计数，所以在需要计数操作的场景下无法使用。<br>  不过书中有提到这么一个办法：</p><pre><code>1. 新建一个方法创建int数组 range(int i)2. foreach直接调用这个方法 for(int i : range(10)){}</code></pre><p>  虽然这样可以让foreach适用更多场景，借此提高代码可读性。但是有些为了使用而使用的感觉。毕竟相对使用for，使用foreach需要先新建一个int数组，这个代价是否值得需要思量。</p><h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><p>  一般我们使用break，continue都是用于跳出循环，break中断并跳出当前循环，continue中断并跳出当次循环。<br>  不过书中提到了标签，这个用的很少，所以记录一下：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标签是跟有冒号的标识符，如 a:，他作用的唯一地方是在一个迭代语句之前，作为break，continue的一个锚</span></span><br><span class="line">a:</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">5</span>; x++) &#123;</span><br><span class="line">    b:</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="number">4</span>; y++) &#123;</span><br><span class="line">        c:</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> z = <span class="number">0</span>; z &lt; <span class="number">3</span>; z++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"start:"</span> + x + <span class="string">","</span> + y);</span><br><span class="line">            <span class="keyword">if</span> (z == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"if:"</span> + z);</span><br><span class="line">                <span class="keyword">continue</span> a;</span><br><span class="line">                <span class="comment">// break a;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  如上述示例代码，三层嵌套的for循环，每一个都加了一个标签。当break/continue后面跟上标签时，在中断循环后，他们会跳到标签所在的位置再继续后续操作。<br>  例如这里的<em>continue a</em>，不加标签的话会跳出当次循环继续z的自增循环，加了标签后，效果变为中断当次循环，跳到标签所在也就是最外层循环然后继续。</p><pre><code>  标签一般用于多层嵌套循环中控制break，continue的跳出位置。但是实际开发中是不建议使用多层嵌套循环的，而且使用不善的话容易降低代码的可阅读性，需要谨慎使用。</code></pre><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><pre><code>操作符与流程控制的关键字都是比较基础的知识点。所以只记录实际开发中较少使用或者没接触过的知识点。</code></pre><blockquote><p>下一章 <a href="https://rel-fly.com/2020/06/07/ThinkingInJava3/">&lt;ThinkingInJava-3&gt;</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> ThinkingInJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ThinkingInJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThinkingInJava-1</title>
      <link href="/2020/06/06/ThinkingInJava1/"/>
      <url>/2020/06/06/ThinkingInJava1/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  准备开始阅读《Thinking in Java(第四版)》，这是Java的经典书籍，看了下目录，基本涵盖了Java编程的所有知识点。<br>  本章先从第一，二章开始记录。</p><a id="more"></a><h3 id="对象导论"><a href="#对象导论" class="headerlink" title="对象导论"></a>对象导论</h3><p>  作为本书的第一章，对象导论围绕面向对象，简述了其思想，设计以及相关的概念。</p><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>  Java是面向对象的编程语言，那么对象，究竟如何理解与定义？</p><p>  先看看面向对象语言的鼻祖-smalltakl的五个特性：</p><pre><code>1. 万物皆对象2. 程序是对象的集合，他们通过发送消息(可以理解为方法的调用)来告知彼此要做什么3. 每个对象都有自己的由其他对象所构成的存储(可以理解成类的聚合和组合关系)4. 每个对象都拥有类型即每个对象都是某个类(class)的一个实例5. 某一特定类型的所有对象都可以接手同样的消息(继承)</code></pre><p>  关于对象，还有这么一个简单的描述：</p><blockquote><p> <em>对象具有状态，行为和标识   —Booch</em></p></blockquote><pre><code>1. 状态：对象拥有的内部数据(属性)2. 行为：对象的方法3. 标识：区分对象的唯一的地址(书中解释到这一点有些过于受限，当对象被存储在不同的机器和地址空间或者           硬盘上时，标识就应该是内存地址之外的其他东西)</code></pre><p>  对象，是遵照一定规则对实际问题的抽象或者说描述。比如：老鹰，新建一个老鹰的类型，它的属性有性别，年龄等，它的行为有飞行，捕食等。<br>  而将属性具体化后，就得到一个对象。通过执行对象的行为来完成对实际问题的描述，例如调用他的飞行方法描述飞翔的过程。</p><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><p>  面向对象的思想其实很好理解，他即是将现实事物转为程序语言去处理。抽象出现实事务的属性和行为作为一个类型，然后创建对应的对象完成对现实问题的描述(可以理解为业务逻辑的完成)。</p><blockquote><p> <em>这是一种更灵活更强有力的语言抽象</em></p></blockquote><p>  这句话应该很好的概括了面向对象的优势。</p><p>  那么谈到面向对象，肯定逃不开抽象，继承，封装，多态：</p><pre><code>1. 抽象，对事务公共属性，行为的归纳提取，创建一个类型。2. 继承，基于现有抽象的新的抽象。即在保留相同属性，行为的基础上建立一个新的类型。而新类型的行为可   以有自己单独的实现方式，而且保留父类的属性行为基础上，还可以增加新的属性和行为   例如：鸟类的飞行行为，继承鸟类的老鹰和麻雀都拥有同样的飞行行为，但两者可飞行的高度不同。而对老   鹰可以增加对其他动物的捕食行为   继承一方面提高了代码的复用性，另一方面也是建立了类与类间的关系，体现了对实际事务的描述3. 封装，目的是隐藏一些没必要被开发者知晓的信息，减少操作带来的bug。是为了程序安全性的一种措施。通   常借助代码的访问控制达成(public,private,protected)4. 多态，基于继承的关系，在编译期可以将一个对象当作他的父类对待，直到运行期才确定他的类型。这种特   性可以提高代码的扩展性，例如：一个方法的入参可以用父类定义，而传参时选择不同的子类以完成不同的   逻辑处理</code></pre><h3 id="一切都是对象"><a href="#一切都是对象" class="headerlink" title="一切都是对象"></a>一切都是对象</h3><p>  本书第二章从对象的创建谈起，逐步讲述了怎样构建一个简单的Java程序，包括编码规范，注释，javadoc标签等。因为是比较基础的内容，所以就摘一些我比较感兴趣的记录一下。</p><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>  Java中对对象的控制是用引用完成的，例如</p><blockquote><p>ClassA a = new ClassA();</p></blockquote><p>  这里初始化一个类型ClassA的对象a，a只是对象的一个引用，是一个地址值，指向堆中实际数据存储的地方。<br>  这也是在参数传递的时候时常容易忽略的问题。<br>  参数如果是对象，传递的是对象的引用值，那么方法内的操作就会反馈到同一对象的所有引用上。<br>  参数如果是基本类型，基本类型存储的是数据本身，这时传递的就是数据的值，所以不影响方法外的基本类型的值。<br>  这里举个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ClassB b = <span class="keyword">new</span> ClassB(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">1</span>;</span><br><span class="line">updateB(b,c);</span><br><span class="line"></span><br><span class="line"><span class="comment">// b的value属性会改变，而c的值不变</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateB</span><span class="params">(ClassB param1, <span class="keyword">int</span> param2)</span></span>&#123;</span><br><span class="line">  param1.value = <span class="number">2</span>;</span><br><span class="line">  param2 = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><p>  static关键字是常用的关键字之一。他开辟独属于类的存储空间，不依赖于对象的创建，是所有对象公有的。<br>  当类第一次加载时，static修饰的方法，属性，代码块就会随之加载，且只会加载这一次。<br>  因此我们可以将一些类的初始化操作(设置默认值等)，常量，公用方法用static修饰处理，因为只会加载一次，所以一方面提升效率，另一方面保证数据不可变。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><pre><code>  书的第一章，第二章比较基础，介绍了面向对象的思想，Java的基础概念。算是温故了一些知识点，不过对面向对象及对象的一些概念的阐述感觉让自己的认知更加清晰了。</code></pre><blockquote><p>下一章 <a href="https://rel-fly.com/2020/06/07/ThinkingInJava2/">&lt;ThinkingInJava-2&gt;</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> ThinkingInJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ThinkingInJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql-InnoDB锁</title>
      <link href="/2020/06/03/innoDBLock/"/>
      <url>/2020/06/03/innoDBLock/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  在了解分布式锁的过程中看到了MySql锁的相关知识，所以针对MySql-InnoDB锁的相关内容做一个梳理。</p><a id="more"></a><h3 id="InnoDB锁"><a href="#InnoDB锁" class="headerlink" title="InnoDB锁"></a>InnoDB锁</h3><p>  相对于MyISAM，InnoDB的不同之处在于引入了事务，并且主要使用的是行级锁而不是表级锁。</p><h4 id="InnoDB事务"><a href="#InnoDB事务" class="headerlink" title="InnoDB事务"></a>InnoDB事务</h4><h5 id="并发事务的问题"><a href="#并发事务的问题" class="headerlink" title="并发事务的问题"></a>并发事务的问题</h5><ol><li>脏读：事务A的未提交的写操作导致的数据修改被另一个事务读到</li><li>不可重复读：一个事务内对同一行数据的前后两次查询结果不一样，由其他事务的update，delete操作影响</li><li>幻读：一个事务内对同一批数据的前后两次查询结果不一样，由其他事务的insert操作影响</li></ol><h5 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h5><img src="/image/innoDBLock/InnoDBLock3.png" class="" title="事务隔离级别"><h4 id="InnoDB的锁模式"><a href="#InnoDB的锁模式" class="headerlink" title="InnoDB的锁模式"></a>InnoDB的锁模式</h4><p>  InnoDB行级锁是针对索引的索引项加锁，也叫记录锁。如果某个sql没有用到索引，那么就会使用聚集索引。<br>  在聚集索引的所有索引项上加锁(类似表级锁)，MySQL之后会进行优化，释放掉不符合条件的索引项的锁。但<br>  这个加锁和释放的过程仍然执行了，所以要保证sql尽量用到索引。</p><h5 id="共享锁与排他锁"><a href="#共享锁与排他锁" class="headerlink" title="共享锁与排他锁"></a>共享锁与排他锁</h5><pre><code>共享锁(s)：读锁，允许一个事务读一行，并阻止其他事务获取相同数据集的排他锁排他锁(x)：写锁，允许一个事务读/写一行，并阻止其他事务获取相同数据集的排他锁和共享锁updat，insert，delete操作会自动加排他锁，而select默认不加锁，在串行读下会加共享锁</code></pre><h5 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h5><pre><code>意向锁属于表级锁，由数据库完成其申请操作，分为意向共享锁和意向排他锁。其解决的问题是：事务A先获取了表table的一个行级写锁，之后事务B想获取table的表级写锁，为了避免冲突逐行检查有没有冲突的行级锁，这样明显很浪费时间。而意向锁的作用就是：在事务申请一个行级锁之前，数据库会自动先申请一个意向锁。如果已经有事务持有该表的表级锁就会等待锁释放，而申请成功后，如果再有事务申请该表的表级锁，也会等待锁释放。这就避免了逐行检查的开销。</code></pre><img src="/image/innoDBLock/InnoDBLock.png" class="" title="意向锁和表级锁的兼容关系"><pre><code>上图是意向锁和表级共享锁，排他锁的兼容关系(绿色表示兼容，红色表示冲突)，可以看到，意向锁之间是不冲突的。从这里就可以看到，意向锁的主要目的还是解决表级锁和行级锁的冲突。有了意向锁作为一种前置判断可以很方便的进行检查防止冲突。</code></pre><h5 id="间隙锁与临键锁"><a href="#间隙锁与临键锁" class="headerlink" title="间隙锁与临键锁"></a>间隙锁与临键锁</h5><p>  前面提到，InnoDB的行级锁是针对索引的索引项的，可以设想这样一种情况：</p><img src="/image/innoDBLock/InnoDBLock2.png" class="" title="示例表"><pre><code>对上图的表数据，age字段存在非唯一索引，那么执行以下sql：事务A：select name,age where age &gt; 4;      update set name = &apos;xx&apos; where age &gt; 4;      select name,age where age &gt; 4;事务B：insert into table(id,name,age) values(5,&apos;bb&apos;,7);按照前文对行级锁的理解，事务A的update操作会通过age的索引锁定主键索引4并加排他锁，事务B的操作不会因为锁阻塞。那么这时事务A的第二个查询就会和第一个查询的结果不一样，莫名多了一条数据。为解决这种问题，就使用了间隙锁(GAP-LOCK)间隙锁(GAP-LOCK)：是指对表中不存在的数据上加锁，一般处于两个数据行的间隙，所以叫间隙锁。用来防止                 其他事务的新增操作导致幻读，通常会在条件是一个范围的时候使用，而如果条件索引是唯                 一索引或者结果是唯一值(可以理解为不会因为其他事务的新增操作影响结果)，会放弃间隙                 锁而只使用记录锁临键锁(Next-Key)：临键锁比较好理解，他等于记录锁+间隙锁</code></pre><h4 id="MVCC-多版本并发控制"><a href="#MVCC-多版本并发控制" class="headerlink" title="MVCC(多版本并发控制)"></a>MVCC(多版本并发控制)</h4><p>  MVCC通过对每一行数据增加两个隐藏值：事务ID，回滚指针，来实现并发控制。<br>  不同事务对一行数据的写操作会产生多个版本，通过回滚指针形成一个链表的结构。<br>  读操作不用加锁，可以减少锁的使用和等待等开销。</p><h5 id="快照读和当前读"><a href="#快照读和当前读" class="headerlink" title="快照读和当前读"></a>快照读和当前读</h5><p>  根据MVCC的版本记录，就产生了两种读取方式：快照读和当前读<br>    快照读：读取记录的可见版本，默认的select就是快照读，不用加锁<br>    当前读：读取记录的最新版本并加锁，防止其他事务的操作，属于当前读的操作有<br>           1. select …… from …… where …… lock in share mode; 加共享锁<br>           2. select …… from …… where …… for update; 加排他锁<br>           3. insert，update，delete</p><h5 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h5><p>  ReadView用来控制快照读的可见版本，其操作原理是在生成ReadView时会保存一个当前活跃事务<br>  ID的列表，在进行select操作时，会将版本链中数据的事务ID与ReadView中的ID列表比对，判断版本是否可见。</p><p>  例如：如果版本的事务ID大于ReadView事务ID列表的最大值，那么说明该版本数据是在生成ReadView之后提交的，自然对当前事务不可见，通过回滚指针遍历之前的版本继续比对。</p><h4 id="不同事务隔离级别的区别"><a href="#不同事务隔离级别的区别" class="headerlink" title="不同事务隔离级别的区别"></a>不同事务隔离级别的区别</h4><ol><li>未提交读：读不加锁，只读取最新版本数据，可以读到未提交的记录</li><li>已提交读：使用MVCC，select使用快照读，写操作只用记录锁<pre><code>每一次select都会生成一个新的ReadView,所以可以读取提交的数据版本，导致不可重复读</code></pre></li><li>可重复读：mysql默认隔离级别<pre><code>使用MVCC，select使用快照读，写操作会使用记录锁，间隙锁和临键锁在第一次select时生成一个ReadView，之后不再改变，所以不会读到之后提交的数据版本，保证前后读取的数据一致性(所以这里也可以防止幻读)</code></pre></li><li>串行读：select加共享锁，读写互斥</li></ol><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>  产生死锁的原因主要就是加锁的顺序不一样，因为MySql的加锁是对符合条件的数据逐行加锁。这就会导致<br>  两个事务持有对方需要的锁，导致互相等待，形成死锁</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><pre><code>  关于MySql-InnoDB锁的相关知识点，对于基本的行锁的概念和作用其实很好理解，包括事务隔离级别及其避免的并发问题，不过在我阅读相关博客时，对一些细节始终没有找到准确的答案，比如ReadView的具体实现方式，间隙锁的具体情况下的加锁操作。这些之后需要找些相关书籍确定答案，这里就还是做一下小结：1.InnoDB的默认事务隔离级别是可重复读，写操作会涉及锁的加载和释放。所以合理的sql操作及索引配置能  够有效减小开销及死锁的风险。这也是sql的优化的一个方向。(所以索引对于sql优化很重要)2.MVCC的版本控制思想是解决并发问题的常用办法，例如：CAS解决aba问题就是添加版本号的方式3.使用select……for update 实现分布式锁就是利用他给行数据添加了排他锁的原理，这样就解决了并发下  对同数据集的操作，不过不想使用锁的话就可以借用版本控制的方法，增加一个版本号的字段进行判断</code></pre>]]></content>
      
      
      <categories>
          
          <category> MySql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> InnoDB锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-位运算符</title>
      <link href="/2020/06/02/bitwiseOperator/"/>
      <url>/2020/06/02/bitwiseOperator/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  在阅读HashMap的源码中，对许多位运算符都分不太清了。所以这里对位运算符做一个复习。</p><a id="more"></a><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>  位运算符的特点是会按照二进制去进行运算，例如3&amp;5，先把3和5转化为二进制，然后每一位进行&amp;运算，得出二进制的结果</p><h4 id="按位非"><a href="#按位非" class="headerlink" title="~  按位非"></a>~  按位非</h4><pre><code>运算规则： ~b 先将b转化为二进制数，对每一位进行取反eg: ~3的计算过程3      00000000 00000000 00000000 00000011result 11111111 11111111 11111111 11111100 (负数这里为补码需要转换)-1     11111111 11111111 11111111 11111011 反码~      10000000 00000000 00000000 00000100 原码 =&gt; -4</code></pre><h4 id="移位"><a href="#移位" class="headerlink" title="移位"></a>移位</h4><h5 id="lt-lt-和-gt-gt"><a href="#lt-lt-和-gt-gt" class="headerlink" title="&lt;&lt; 和 &gt;&gt;"></a>&lt;&lt; 和 &gt;&gt;</h5><pre><code>a&lt;&lt;b 左移位操作符，将a的二进制向左移动b位，0补位，等同于乘以2的b次方 eg： 3&lt;&lt;2=123      00000000 00000000 00000000 00000011-&gt;     00000000 00000000 00000000 00001100a&gt;&gt;b 右移位操作符，将a的二进制向右移动b位，正数0补位，负数1补位，等同于除以2的b次方 eg： 4&gt;&gt;2=14      00000000 00000000 00000000 00000100-&gt;     00000000 00000000 00000000 00000001eg： -4&gt;&gt;2=-1-4     11111111 11111111 11111111 11111100-&gt;     11111111 11111111 11111111 11111111 (负数这里为补码需要转换)-1     11111111 11111111 11111111 11111110 反码~      10000000 00000000 00000000 00000001 原码 =&gt; -1</code></pre><h5 id="gt-gt-gt-无符号右移"><a href="#gt-gt-gt-无符号右移" class="headerlink" title="&gt;&gt;&gt;  无符号右移"></a>&gt;&gt;&gt;  无符号右移</h5><pre><code>类似&gt;&gt;，区别在于不管正数负数都用0补位eg： -4&gt;&gt;&gt;2=1073741823-4     11111111 11111111 11111111 11111100-&gt;     00111111 11111111 11111111 11111111</code></pre><h4 id="amp-按位与"><a href="#amp-按位与" class="headerlink" title="&amp;  按位与"></a>&amp;  按位与</h4><pre><code>运算规则： a&amp;b 先将a,b转化为二进制数，当且仅当相同位数都为1时，结果是1，否则为0eg: 3&amp;5的计算过程3      00000000 00000000 00000000 000000115      00000000 00000000 00000000 00000101result 00000000 00000000 00000000 00000001 =&gt; 1</code></pre><h4 id="按位或"><a href="#按位或" class="headerlink" title="|  按位或"></a>|  按位或</h4><pre><code>运算规则： a|b 先将a,b转化为二进制数，当且仅当相同位数都为0时，结果是0，否则为1eg: 3|5的计算过程3      00000000 00000000 00000000 000000115      00000000 00000000 00000000 00000101result 00000000 00000000 00000000 00000111 =&gt; 7</code></pre><h4 id="按位异或"><a href="#按位异或" class="headerlink" title="^  按位异或"></a>^  按位异或</h4><pre><code>运算规则： a^b 先将a,b转化为二进制数，当且仅当相同位数只有一个为1时，结果是1，否则为0eg: 3^5的计算过程3      00000000 00000000 00000000 000000115      00000000 00000000 00000000 00000101result 00000000 00000000 00000000 00000110 =&gt; 6</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap(jdk1.8)</title>
      <link href="/2020/05/30/hashMap1/"/>
      <url>/2020/05/30/hashMap1/</url>
      
        <content type="html"><![CDATA[<h3 id="HashMap简介"><a href="#HashMap简介" class="headerlink" title="HashMap简介"></a>HashMap简介</h3><pre><code>  HashMap是java.util包下的实现Map接口的非线程安全集合，其基于数组+链表|红黑树的结构，以键值对的形式存储数据特点：1. 基于key-value的数据结构可以通过key直接定位value值，查询较快，key值可为null2. 使用hash值确定数组下标，所以遍历顺序不是输入顺序3. 扩容操作涉及重新计算hash值，对性能影响较大，需尽量避免</code></pre><a id="more"></a><p>类定义如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><h3 id="源码部分解析"><a href="#源码部分解析" class="headerlink" title="源码部分解析"></a>源码部分解析</h3><h4 id="属性信息"><a href="#属性信息" class="headerlink" title="属性信息"></a>属性信息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ------------------设置的默认值-----------------------</span></span><br><span class="line"><span class="comment">// 数组的默认容量  (需为2的n次方，涉及扩容时的计算)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组的最大容量 2的30次方</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认的加载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 树化的阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消树化的阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 树化时的数组容量最小值 </span></span><br><span class="line"><span class="comment">// 当容量小于该值时应考虑增加数组容量而不是将链表变化为树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------基本属性---------------------------</span></span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 键值对集合</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 集合中键值对的数量</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构变化的计数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 键值对数量的阈值  计算方式 capacity * loadFactor</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化数组容量和加载因子的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">// 键值对数量的阈值 为数组容量的两倍  tableSizeFor(int cap) 返回cap的两倍</span></span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化数组容量 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用默认的加载因子初始化</span></span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用默认值初始化一个空的hashmap</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用指定的map集合初始化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组下标的计算"><a href="#数组下标的计算" class="headerlink" title="数组下标的计算"></a>数组下标的计算</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算hash值</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">// key为null就取0，否则用 h 异或 h 无符号右移16位</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算数组下标 n表示数组长度 &amp; 按位与</span></span><br><span class="line">(n - <span class="number">1</span>) &amp; hash</span><br></pre></td></tr></table></figure><p>关于以上计算的具体分析，可以参考美团技术团队的文章&lt;Java 8系列之重新认识HashMap&gt;</p><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><h5 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对外暴露的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部实现逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">// 数组下标的计算 (n-1) &amp; hash</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 定位数组位置后，先判断头节点是否匹配</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断如果是树结构，走树的遍历</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 链表的遍历</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ---------------------------内部类 TreeNode 的方法-----------------------------------</span></span><br><span class="line"><span class="comment">// 获取符合条件的树节点</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">getTreeNode</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从根节点开始找</span></span><br><span class="line">    <span class="keyword">return</span> ((parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>).find(h, k, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 树节点遍历比对</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> ph, dir; K pk;</span><br><span class="line">        TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;</span><br><span class="line">        <span class="comment">// 查找节点hash值小于当前值，转向左子节点</span></span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">            p = pl;</span><br><span class="line">        <span class="comment">// 反之，转向右子节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">            p = pr;</span><br><span class="line">        <span class="comment">// 直接匹配，返回当前节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="comment">// 排除本节点且无法定位下一步的情况，看左右子节点是否有为空的</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="keyword">null</span>)</span><br><span class="line">            p = pr;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="keyword">null</span>)</span><br><span class="line">            p = pl;</span><br><span class="line">        <span class="comment">// 左右节点都不为空的前提下，比较key值来确定下一步去左边还是右边</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="keyword">null</span> ||</span><br><span class="line">                  (kc = comparableClassFor(k)) != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">                 (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)</span><br><span class="line">            p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">        <span class="comment">// 前面的判断都没得出结果</span></span><br><span class="line">        <span class="comment">// 递归遍历右子树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> q;</span><br><span class="line">        <span class="comment">// 右子树没找到结果，就找左子树</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = pl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对外暴露的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体实现逻辑</span></span><br><span class="line"><span class="comment">// @param onlyIfAbsent  如果为true，不更改现有值</span></span><br><span class="line"><span class="comment">// @param evict 如果为false table处于创建模式</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 初始化table</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 计算下标 (n-1) &amp; hash, 若下标对应的值为null，则创建一个Node对象赋值</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 首节点 p 不为null</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 比较hash值和key值</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 如果是红黑树结构，走树的逻辑</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 链表的遍历赋值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        <span class="comment">// 判断链表长度，是否需要树化</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// key存在的处理</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 扩容的判断</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 树化的逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 如果数组为空或长度太小，不会选择树化，而是扩容</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);<span class="comment">// 替换节点对象</span></span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 调用TreeNode的方法完成树化</span></span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容方法</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 原数组不为空的前提</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 阈值判断</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不超出阈值的前提下，扩容为2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 计算新的键值对阈值</span></span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">// table扩容 重新计算数组下标</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">// 树结构的处理</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------内部类 TreeNode 的方法-----------------------------------------</span></span><br><span class="line"><span class="comment">// 树结构的put方法</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> searched = <span class="keyword">false</span>; <span class="comment">// 是否遍历过</span></span><br><span class="line">    TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">        <span class="comment">// 查找key是否在树中存在</span></span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">            dir = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">            dir = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp; (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                 (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                searched = <span class="keyword">true</span>; <span class="comment">// 避免后续循环再走到此逻辑中</span></span><br><span class="line">                <span class="comment">// 递归find方法，分别遍历左右子树</span></span><br><span class="line">                <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp; (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                    ((ch = p.right) != <span class="keyword">null</span> &amp;&amp; (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">            &#125;</span><br><span class="line">            dir = tieBreakOrder(k, pk);</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">        <span class="comment">// 新建树节点</span></span><br><span class="line">        <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">            TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">            <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                xp.left = x;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                xp.right = x;</span><br><span class="line">            xp.next = x;</span><br><span class="line">            x.parent = x.prev = xp;</span><br><span class="line">            <span class="keyword">if</span> (xpn != <span class="keyword">null</span>)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">            moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 树化具体实现</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; root = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">        x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 确定根节点 红黑树根节点为黑色</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            x.parent = <span class="keyword">null</span>;</span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            root = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左右子节点的判定，与get，put中的判断类似</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            K k = x.key;</span><br><span class="line">            <span class="keyword">int</span> h = x.hash;</span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> dir, ph;</span><br><span class="line">                K pk = p.key;</span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    x.parent = xp;</span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    <span class="comment">// 平衡插入 暂时没完全看懂 这里就贴出来</span></span><br><span class="line">                    root = balanceInsertion(root, x);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保证树的头节点在table中</span></span><br><span class="line">    moveRootToFront(tab, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><pre><code>   HashMap相对ArrayList复杂许多，涉及红黑树的操作逻辑都很值得琢磨。因为篇幅问题，只从源码中摘出我认为较常用的方法(get，put)和一些重要的逻辑。分析源码逻辑确实受益良多，一些想法中直接简单的逻辑，为了保证代码的健壮性，实现起来往往就会复杂许多。例如涉及红黑树的一些处理，做了很多判断，遍历，递归之类的，一开始感觉有些重复了，思考良久之后才理解为什么。这里照旧小结一下：1. HashMap中涉及了较多的位运算，异或，按位与之类的。因为实际工作中较少使用，导致对这些位运算都比较陌生了，需要对位运算复习一下2. 源码中许多方法都是使用了局部变量去处理，比如红黑树的判断，都是在方法中定义变量指向树的根节点或左右子节点再去处理。我理解的原因第一是局部变量能在方法结束后被回收，第二应该是避免直接操作导致原对象的错误更改。(虽然有时候这样的处理增加了代码阅读的难度···)3. 红黑树的相关操作(TreeNode的一些方法)，虽然有些方法没完全看懂，但是可以作为树结构操作的一个参考</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Map </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList(jdk1.8)</title>
      <link href="/2020/05/26/arrayList1/"/>
      <url>/2020/05/26/arrayList1/</url>
      
        <content type="html"><![CDATA[<h3 id="ArrayList简介"><a href="#ArrayList简介" class="headerlink" title="ArrayList简介"></a>ArrayList简介</h3><pre><code>ArrayList是java.util包下实现List接口的非线程安全的动态数组类优点：基于数组结构，可通过下标快速定位，查询效率快；新增涉及扩容判断，在不扩容      的前提下，效率也较快缺点：删除，扩容操作基于数组的复制，代价较高</code></pre><a id="more"></a><p>类定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><h4 id="属性信息"><a href="#属性信息" class="headerlink" title="属性信息"></a>属性信息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认的初始容量(存储ArrayList数据的数组长度)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空实例的共享空数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有默认大小的空实例的共享数组，与 EMPTY_ELEMENTDATA 区分开，是为了在第一次add的时候做判断</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储ArrayList元素的数组缓冲区</span></span><br><span class="line"><span class="comment">// 这里使用transient避免elementData的序列化，是为了防止序列化对ArrayList开辟</span></span><br><span class="line"><span class="comment">// 的预留空间处理，节省空间和时间</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ArrayList包含的元素个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构变化(新增，删除，扩容)的次数，是Fail-Fast的判断标准</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组可分配的最大值</span></span><br><span class="line"><span class="comment">// -8 根据源码注释是由于虚拟机限制，尝试分配更大空间会容易导致</span></span><br><span class="line"><span class="comment">// OutOfMemoryError: Requested array size exceeds VM limit</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br></pre></td></tr></table></figure><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ol><li><p>构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定初始化容量的构造方法</span></span><br><span class="line"><span class="comment">// 可以看到容量为0的会将elementData指向 EMPTY_ELEMENTDATA 即实例共享的空数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参构造方法，这里elementData初始化为 DEFAULTCAPACITY_EMPTY_ELEMENTDATA，表示容量默认10</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造一个包含指定集合的list</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            <span class="title">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>其他方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组容量的判断</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当数组为空且有默认容量时，取两者大的一个</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 容量更新的判断</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加容量的操作</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// 扩容为旧容量的1.5倍，x &gt;&gt; 1(向右位移1位) == x/2</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 容量超出最大值的处理</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="comment">// 这里并不禁止使用Integer.MAX_VALUE</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增时的下标校验</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>基本操作方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新增方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定下标的新增方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素的替换</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除指定下标的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断index是否大于size，大于则抛出IndexOutOfBoundsException</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 这里涉及对数组的复制</span></span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除第一次出现的指定元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 跳过边界校验的删除操作</span></span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增一个集合的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">    <span class="comment">// 使用数组复制操作</span></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><pre><code>  这里只是列出了ArrayList部分常用方法的源码。ArrayList相对比较简单容易理解，但通过对源码的解读，依然能有一些收获:1. 使用时需要注意其基于数组复制的操作，例如扩容，删除等。2. 数组大小默认是10，每次扩容会变为原来的1.5倍大小。建议按照实际场景提前设置默认容量，可以避免扩   容操作3. 可以看到对于数组边界之类的判断，源码中做得很充分，能够有效保证代码的安全性4. 对无用的数组元素及时赋值null，使其能够被GC处理5. 方法封装的一些处理，根据不同场景的需要封装方法，而不是一味的将相同的代码封装为一个方法，使得代   码更容易被理解</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Collection </category>
          
          <category> List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql-索引</title>
      <link href="/2020/05/25/mysql1/"/>
      <url>/2020/05/25/mysql1/</url>
      
        <content type="html"><![CDATA[<h3 id="索引结构-B-树"><a href="#索引结构-B-树" class="headerlink" title="索引结构-B+树"></a>索引结构-B+树</h3><h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4><p>m阶B+树满足一下条件：</p><ol><li>根结点的分支数量[k]范围为[2，m]</li><li>每个分支结点包含的分支数[x]范围为[ceil(m/2), m]</li><li>分支结点的关键字数量[y]等于[x-1]，所以[y]的范围是[ceil(m/2)-1, m-1]，关键字顺序递增</li><li>所有叶子结点都在同一层，且形成一个有序链表<a id="more"></a></li></ol><h4 id="操作导致的结构变化"><a href="#操作导致的结构变化" class="headerlink" title="操作导致的结构变化"></a>操作导致的结构变化</h4><h5 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h5><ul><li>所有节点都没有满，直接插入</li><li>节点满了，将节点拆分为左右两个节点，将中间的关键字提向上一节点<pre><code>节点的拆分对性能影响较大(涉及磁盘的数据移动)，所以某些情况下会使用旋转操作代替节点拆分当需要拆分的叶子节点左右节点存在未满的情况(一般优先检查左节点)，会将已满的叶子节点的关键字分到未满的相邻节点，并替换上一级节点的关键字，确保排序正确</code></pre></li></ul><h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><p>   删除根据填充因子(fill factor)判断是否变化节点</p><ul><li>节点关键字数目满足要求，直接删除，如果该关键字还存在于非叶子节点中，用该关键字右边的关键字代替</li><li>节点关键字数目少，与其兄弟节点合并，并更新上一级节点关键字，确保排序正确</li></ul><h3 id="innoDB索引"><a href="#innoDB索引" class="headerlink" title="innoDB索引"></a>innoDB索引</h3><h4 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h4><ol><li>聚簇索引：索引项的顺序与表中记录的物理顺序一致，且叶子节点存储了对应数据行的数据。innoDB中主键即为聚簇索引</li><li>非聚簇索引：叶子节点存储的是对应逐渐的值，索引项的顺序与表中记录的物理顺序没有关联性。对非聚簇索引的查询最后都会落到聚簇索引的二次查询。</li></ol><h4 id="回表与索引覆盖"><a href="#回表与索引覆盖" class="headerlink" title="回表与索引覆盖"></a>回表与索引覆盖</h4><ol><li>回表：通过非聚簇索引查询，先通过非聚簇索引定位到主键值，再通过聚簇索引得到行数据。因此走了两边B+树的遍历，被称为回表查询。</li><li>索引覆盖：针对组合索引来说，是指能在索引树中直接获取需要查询的全部数据，无需通过主键二次查询。避免了回表查询。</li></ol><h3 id="sql优化"><a href="#sql优化" class="headerlink" title="sql优化"></a>sql优化</h3><h4 id="执行计划explain"><a href="#执行计划explain" class="headerlink" title="执行计划explain"></a>执行计划explain</h4><p>explain命令是对sql执行的分析，主要关注type和extra两个信息：</p><ul><li><p>type： 使用索引的级别</p><pre><code>1. all：全表扫描2. index：全索引扫描，通常出现在查询数据可直接在索引树中获取到，不需要获取行数据3. range：使用索引范围查询4. ref：查找条件使用了索引但是部位主键或者唯一索引，存在重复的值5. eq_ref：查找条件使用的索引为主键或者唯一索引6. const：将主键放置到where后面作为条件查询，mysql优化器能对这次查询进行优化转为一个常量</code></pre></li><li><p>extra：重要补充信息</p><pre><code>1. using filesort：进行额外的排序操作，无法使用索引排序2. using temporary：使用临时表保存中间结果，通常由于排序，分组，多表join导致3. using index：使用了索引覆盖，说明无需回表查询4. using index condition ：条件包含索引和未索引的列，优化器将首先解析索引的列，并在表中查找                           其他条件的行（将索引下推），MySql5.6的新特性5. using where：使用where中的条件来进行表扫描‘using where; using index’ 与 ‘using condition’相比前者更好</code></pre></li></ul><h4 id="索引分析show-index-from"><a href="#索引分析show-index-from" class="headerlink" title="索引分析show index from"></a>索引分析show index from</h4><p>对表中索引的相关分析，以下是相对重要的信息：</p><ul><li>seq_in_index：该列在索引中的位置，索引单列则为1，组合索引则为索引定义中的顺序</li><li>collation：索引的存储顺序，A表示升序，NULL表示无分类</li><li>cardinality：唯一值数目的估计值，数值越大越好</li><li>sub_part：被编入索引的字符数量，NULL表示全被编入</li><li>null：索引是否包含NULL，YES表示有，NO表示没有。通常不建议索引带有NULL值</li></ul><h4 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h4><ol><li>索引的创建应选择区分度高的列，且避免有NULL值(建表字段建议都设置为非null的并加上默认值)</li><li>控制索引的长度，对于varchar等类型的列新建索引时，在保证高区分度的前提下，尽量取最短的前缀作为索引值</li><li>通过对sql的explain结果针对性优化，通常需要保证type的级别高于index。且需要注意extra中<br>出现using filesort或using temporary，这都是低效率的象征。</li><li>避免复杂的联表查询，最好控制在三张表左右的关联(受表的数量级影响)</li><li>排序，分组等操作需要注意是否能使用到索引</li></ol>]]></content>
      
      
      <categories>
          
          <category> MySql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySql索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis部分知识点梳理</title>
      <link href="/2020/05/24/redis1/"/>
      <url>/2020/05/24/redis1/</url>
      
        <content type="html"><![CDATA[<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><ol><li>String：键值对形式，最简单的数据类型<br>应用场景：计数(String有自增/递减令明令-incr/decr key)，简单缓存</li><li>List：双向链表，按照插入顺序排序，可从左/右插入/弹出数据<br>应用场景：消息队列等</li><li>Map：value值为map类型，可以处理更加复杂的数据结构<br>应用场景：一些对象的存储等</li><li>Set：无序集合，自动排重，有交集，并集，差集等操作<br>应用场景：适合于对多个集合数据的处理</li><li>ZSet：与set类似，相比set多了一个用来排序的属性score<br>应用场景：排行榜，带有权重的数据集合等<a id="more"></a></li></ol><h3 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h3><ol><li>key的命名最好有一定规则，便于管理</li><li>redis是单线程，串行执行命令。在线上环境禁止使用keys等命令导致阻塞</li><li>生命周期的设置，对热点数据的缓存生命周期应当避免过于集中，防止同一时间大量热点数据失效，请求全部直接进入数据库</li></ol><h3 id="线上问题及解决方案"><a href="#线上问题及解决方案" class="headerlink" title="线上问题及解决方案"></a>线上问题及解决方案</h3><ol><li>数据一致性<br>问题：如何保证数据库数据与缓存数据的一致性<br>解决方案： <pre><code>1 查询时先取缓存，缓存为空取数据库并补充到缓存2 更新操作先清空缓存，再更新数据库并补充到缓存3 高并发场景下引入队列，将写操作和读操作放入队列依次执行，等待写操作完成再读</code></pre></li><li>缓存雪崩<br>问题：缓存压力过大导致redis服务崩溃，请求全部进入数据库<br>解决方案： <pre><code>1 使用redis高可用方案，主从+哨兵，redis cluster等防止服务崩溃2 后备方案，如果服务仍然意外崩溃，及时限流&amp;降级，防止连锁问题3 对redis服务崩溃后的数据恢复问题，使用redis持久化</code></pre></li><li>缓存穿透<br>问题：请求的key不在缓存中，绕过了缓存查数据库<br>解决方案： <pre><code>1 查不到的数据也增加一个缓存(无法解决恶意攻击的问题)2 使用布隆算法，识别key</code></pre></li><li>缓存击穿<br>问题：热点数据key失效瞬间，大量请求直达数据库<br>解决方案： <pre><code>1 针对缓存生命周期可设置永不失效或者使用定时任务维护达到不失效的效果2 使用互斥锁，防止大量请求同时进入，待一个请求查询完成后重构缓存，后面的请求即可走缓存查询</code></pre></li><li>并发竞争<br>问题：并发场景下，对同一个key的写操作<br>解决方案： <pre><code>1 分布式锁确保同一时间只有一个实例操作2 使用时间戳判断数据有效性</code></pre></li></ol><h3 id="redis持久化"><a href="#redis持久化" class="headerlink" title="redis持久化"></a>redis持久化</h3><ol><li>RDB(默认方案)<br>实现方式：创建一个子进程，与父进程共享数据段，将数据写入一个临时文件，写入成功后会替换掉之前的文件<br>触发方式：在指定的时间间隔内执行了指定的操作次数<br>优点：只有一个数据文件，便于管理维护；性能较好；适用于大数据量的恢复<br>缺点：由于是在指定时间间隔内执行，存在丢失部分数据的情况</li><li>AOF<br>实现方式：将写命令以日志的形式存储在文件中，若文件过大，会触发文件重写操作，减小文件体积<br>优点：不存在数据丢失情况<br>缺点：相比RDB性能较差，文件大，恢复速度慢</li></ol>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视频url的处理</title>
      <link href="/2020/05/09/%E8%A7%86%E9%A2%91%E6%93%8D%E4%BD%9C/"/>
      <url>/2020/05/09/%E8%A7%86%E9%A2%91%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h3 id="视频url的处理"><a href="#视频url的处理" class="headerlink" title="视频url的处理"></a>视频url的处理</h3><ol><li>从url中读取流</li><li>将流转化为文件</li><li>使用MultimediaInfo中的方法获取视频文件的信息<a id="more"></a></li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 添加依赖 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;it.sauronsoftware&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jave&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> it.sauronsoftware.jave.Encoder;</span><br><span class="line"><span class="keyword">import</span> it.sauronsoftware.jave.EncoderException;</span><br><span class="line"><span class="keyword">import</span> it.sauronsoftware.jave.MultimediaInfo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为收到的是链接地址，所以需要先将链接转化为文件</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从链接地址读取流</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> urlPath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InputStream <span class="title">getIsFromUrl</span><span class="params">(String urlPath)</span> </span>&#123;</span><br><span class="line">        HttpURLConnection conn = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String urlStr = URLDecoder.decode(urlPath, <span class="string">"UTF-8"</span>);</span><br><span class="line">            URL url = <span class="keyword">new</span> URL(urlStr);</span><br><span class="line">            conn = (HttpURLConnection) url.openConnection();</span><br><span class="line">            conn.setRequestMethod(<span class="string">"GET"</span>);</span><br><span class="line">            conn.setConnectTimeout(<span class="number">3000</span>);</span><br><span class="line">            <span class="keyword">return</span> conn.getInputStream();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">            logger.error(<span class="string">"[Method-getIsFromUrl]exception:&#123;&#125;"</span>, ioe.getMessage());</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                conn.disconnect();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将流读成文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ins</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inputStreamToFile</span><span class="params">(InputStream ins, File file)</span> </span>&#123;</span><br><span class="line">        OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            os = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">            <span class="keyword">int</span> bytesRead = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> a = <span class="number">8192</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[a];</span><br><span class="line">            <span class="keyword">while</span> ((bytesRead = ins.read(buffer, <span class="number">0</span>, a)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                os.write(buffer, <span class="number">0</span>, bytesRead);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">            logger.error(<span class="string">"[Method-inputStreamToFile]exception:&#123;&#125;"</span>, ioe.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != os) &#123;</span><br><span class="line">                    os.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                logger.error(<span class="string">"[Method-inputStreamToFile]close-exception:&#123;&#125;"</span>, ioe.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取网络文件，暂存为临时文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tempPath 临时文件地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnknownHostException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> File <span class="title">getFileFromUrl</span><span class="params">(String url, String tempPath)</span> </span></span><br><span class="line"><span class="function">                                      <span class="keyword">throws</span> UnknownHostException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建临时文件</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(tempPath);</span><br><span class="line">        File tmpFile = File.createTempFile(<span class="string">"temp"</span>, <span class="string">".tmp"</span>, file);</span><br><span class="line">        <span class="comment">// 程序结束后删除（缓存delete命令，jvm停止时执行）</span></span><br><span class="line">        tmpFile.deleteOnExit();</span><br><span class="line">        logger.info(<span class="string">"[getFileFromUrl]create file from url:&#123;&#125;,path:&#123;&#125;"</span>, </span><br><span class="line">                        url, file.getAbsolutePath());</span><br><span class="line">        InputStream is = getIsFromUrl(url);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != is) &#123;</span><br><span class="line">            inputStreamToFile(is, tmpFile);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmpFile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取视频时长 单位秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">getDuration</span><span class="params">(File file)</span> <span class="keyword">throws</span> EncoderException </span>&#123;</span><br><span class="line">        MultimediaInfo m = <span class="keyword">new</span> Encoder().getInfo(file);</span><br><span class="line">        <span class="keyword">return</span> m.getDuration() / <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上述代码就是获取一个视频地址视频时长的全部内容。逻辑比较简单，先把链接地址读取成文件流，<br>然后用jave的方法获取其时长(单位是毫秒，因为业务需求将其计算转为秒)。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
